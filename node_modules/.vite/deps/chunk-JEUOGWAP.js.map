{
  "version": 3,
  "sources": ["../../../dev/core/src/AudioV2/abstractAudio/abstractAudioNode.ts", "../../../dev/core/src/AudioV2/abstractAudio/subNodes/abstractAudioSubGraph.ts", "../../../dev/core/src/AudioV2/abstractAudio/subNodes/abstractAudioSubNode.ts", "../../../dev/core/src/AudioV2/abstractAudio/subNodes/volumeAudioSubNode.ts", "../../../dev/core/src/AudioV2/webAudio/subNodes/volumeWebAudioSubNode.ts", "../../../dev/core/src/AudioV2/webAudio/subNodes/webAudioBaseSubGraph.ts"],
  "sourcesContent": ["import { Observable } from \"../../Misc/observable\";\nimport type { AudioEngineV2 } from \"./audioEngineV2\";\n\nexport const enum AudioNodeType {\n    HAS_INPUTS = 1,\n    HAS_OUTPUTS = 2,\n    HAS_INPUTS_AND_OUTPUTS = 3,\n}\n\n/**\n * Abstract class for an audio node.\n *\n * An audio node is a processing unit that can receive audio data from an upstream node and/or send audio data to a\n * downstream node.\n *\n * Nodes can be connected to other nodes to create an audio graph. The audio graph represents the flow of audio data.\n *\n * There are 3 types of audio nodes:\n * 1. Input: Receives audio data from upstream nodes.\n * 2. Output: Sends audio data to downstream nodes.\n * 3. Input/Output: Receives audio data from upstream nodes and sends audio data to downstream nodes.\n */\nexport abstract class AbstractAudioNode {\n    /**\n     * The connected downstream audio nodes.\n     * - Undefined for input nodes.\n     */\n    protected readonly _downstreamNodes?: Set<AbstractAudioNode>;\n\n    /**\n     * The connected upstream audio nodes.\n     * - Undefined for output nodes.\n     */\n    protected readonly _upstreamNodes?: Set<AbstractAudioNode>;\n\n    /**\n     * The audio engine this node belongs to.\n     */\n    public readonly engine: AudioEngineV2;\n\n    /**\n     * Observable for when the audio node is disposed.\n     */\n    public readonly onDisposeObservable = new Observable<AbstractAudioNode>();\n\n    protected constructor(engine: AudioEngineV2, nodeType: AudioNodeType) {\n        this.engine = engine;\n\n        if (nodeType & AudioNodeType.HAS_INPUTS) {\n            this._upstreamNodes = new Set<AbstractAudioNode>();\n        }\n\n        if (nodeType & AudioNodeType.HAS_OUTPUTS) {\n            this._downstreamNodes = new Set<AbstractAudioNode>();\n        }\n    }\n\n    /**\n     * Releases associated resources.\n     * - Triggers `onDisposeObservable`.\n     * @see {@link onDisposeObservable}\n     */\n    public dispose(): void {\n        if (this._downstreamNodes) {\n            for (const node of Array.from(this._downstreamNodes)) {\n                if (!this._disconnect(node)) {\n                    throw new Error(\"Disconnect failed\");\n                }\n            }\n            this._downstreamNodes.clear();\n        }\n\n        if (this._upstreamNodes) {\n            for (const node of Array.from(this._upstreamNodes)) {\n                if (!node._disconnect(this)) {\n                    throw new Error(\"Disconnect failed\");\n                }\n            }\n            this._upstreamNodes.clear();\n        }\n\n        this.onDisposeObservable.notifyObservers(this);\n        this.onDisposeObservable.clear();\n    }\n\n    /**\n     * Gets a string identifying the name of the class\n     * @returns the class's name as a string\n     */\n    public abstract getClassName(): string;\n\n    /**\n     * Connect to a downstream audio input node.\n     * @param node - The downstream audio input node to connect\n     * @returns `true` if the node is successfully connected; otherwise `false`\n     */\n    protected _connect(node: AbstractAudioNode): boolean {\n        if (!this._downstreamNodes) {\n            return false;\n        }\n\n        if (this._downstreamNodes.has(node)) {\n            return false;\n        }\n\n        if (!node._onConnect(this)) {\n            return false;\n        }\n\n        this._downstreamNodes.add(node);\n\n        return true;\n    }\n\n    /**\n     * Disconnects a downstream audio input node.\n     * @param node - The downstream audio input node to disconnect\n     * @returns `true` if the node is successfully disconnected; otherwise `false`\n     */\n    protected _disconnect(node: AbstractAudioNode): boolean {\n        if (!this._downstreamNodes) {\n            return false;\n        }\n\n        if (!this._downstreamNodes.delete(node)) {\n            return false;\n        }\n\n        return node._onDisconnect(this);\n    }\n\n    /**\n     * Called when an upstream audio output node is connecting.\n     * @param node - The connecting upstream audio node\n     * @returns `true` if the node is successfully connected; otherwise `false`\n     */\n    private _onConnect(node: AbstractAudioNode): boolean {\n        if (!this._upstreamNodes) {\n            return false;\n        }\n\n        if (this._upstreamNodes.has(node)) {\n            return false;\n        }\n\n        this._upstreamNodes.add(node);\n\n        return true;\n    }\n\n    /**\n     * Called when an upstream audio output node disconnects.\n     * @param node - The disconnecting upstream audio node\n     * @returns `true` if node is sucessfully disconnected; otherwise `false`\n     */\n    private _onDisconnect(node: AbstractAudioNode): boolean {\n        return this._upstreamNodes?.delete(node) ?? false;\n    }\n}\n\n/**\n * Abstract class for a named audio node.\n */\nexport abstract class AbstractNamedAudioNode extends AbstractAudioNode {\n    private _name: string;\n\n    /**\n     * Observable for when the audio node is renamed.\n     */\n    public readonly onNameChangedObservable = new Observable<{ newName: string; oldName: string; node: AbstractNamedAudioNode }>();\n\n    protected constructor(name: string, engine: AudioEngineV2, nodeType: AudioNodeType) {\n        super(engine, nodeType);\n\n        this._name = name;\n    }\n\n    /**\n     * The name of the audio node.\n     * - Triggers `onNameChangedObservable` when changed.\n     * @see {@link onNameChangedObservable}\n     */\n    public get name(): string {\n        return this._name;\n    }\n\n    public set name(newName: string) {\n        if (this._name === newName) {\n            return;\n        }\n\n        const oldName = this._name;\n\n        this._name = newName;\n\n        this.onNameChangedObservable.notifyObservers({ newName, oldName, node: this });\n    }\n\n    public override dispose(): void {\n        super.dispose();\n\n        this.onNameChangedObservable.clear();\n    }\n}\n", "import type { Nullable } from \"../../../types\";\nimport type { AbstractAudioNode, AbstractNamedAudioNode } from \"../abstractAudioNode\";\nimport type { _AbstractAudioSubNode } from \"./abstractAudioSubNode\";\n\n/**\n * Adds common sub graph functionality to an audio node.\n *\n * Audio nodes such as static sounds, streaming sounds, and buses can use audio sub graphs to process audio internally\n * before sending it to connected downstream audio nodes. This is useful for applying effects, spatial audio, and other\n * audio processing tasks common to multiple audio node classes.\n *\n * A key feature of audio sub graphs is their audio sub nodes are created asynchronously on demand so the minimum set\n * of sub nodes are used at all times to save memory and CPU resources. The tradeoff is a small delay when first\n * setting a property backed by a sub node. This delay is avoided by using the appropriate options to initialize the\n * sub node on creation, e.g. `spatialEnabled` and `stereoEnabled`, or by setting any creation option backed by the\n * sub node, e.g. `spatialPosition` and `stereoPan`.\n *\n * @internal\n */\nexport abstract class _AbstractAudioSubGraph {\n    private _createSubNodePromises: { [key: string]: Promise<_AbstractAudioSubNode> } = {};\n    private _subNodes: { [key: string]: AbstractNamedAudioNode } = {};\n\n    /**\n     * Executes the given callback with the named sub node, creating the sub node if needed.\n     *\n     * Note that `callback` is executed synchronously if the sub node already exists, otherwise the sub node is created\n     * asynchronously before `callback` is executed.\n     *\n     * @param name The name of the sub node\n     * @param callback The function to call with the named sub node\n     */\n    public callOnSubNode<T extends _AbstractAudioSubNode>(name: string, callback: (node: T) => void): void {\n        const node = this.getSubNode(name);\n        if (node) {\n            callback(node as T);\n            return;\n        }\n\n        const promise = this._createSubNodePromises[name] ?? this._createAndAddSubNode(name);\n\n        promise.then((node) => {\n            callback(node as T);\n        });\n    }\n\n    /**\n     * Releases associated resources.\n     */\n    public dispose() {\n        const subNodes = Object.values(this._subNodes);\n        for (const subNode of subNodes) {\n            subNode.dispose();\n        }\n\n        this._subNodes = {};\n        this._createSubNodePromises = {};\n    }\n\n    /**\n     * Gets a previously created sub node.\n     * @param name - The name of the sub node\n     * @returns The named sub node, or `null` if it has not been created, yet\n     * @internal\n     * */\n    public getSubNode<T extends AbstractNamedAudioNode>(name: string): Nullable<T> {\n        return (this._subNodes[name] as T) ?? null;\n    }\n\n    protected abstract _createSubNode(name: string): Nullable<Promise<_AbstractAudioSubNode>>;\n\n    /**\n     * Called when sub-nodes are added or removed.\n     * - Override this to connect and reconnect sub-nodes as needed.\n     */\n    protected _onSubNodesChanged(): void {}\n\n    protected _createSubNodePromisesResolved(): Promise<_AbstractAudioSubNode[]> {\n        return Promise.all(Object.values(this._createSubNodePromises));\n    }\n\n    private _addSubNode(node: AbstractNamedAudioNode): void {\n        this._subNodes[node.name] = node;\n\n        node.onDisposeObservable.addOnce(this._onSubNodeDisposed);\n\n        this._onSubNodesChanged();\n    }\n\n    protected _createAndAddSubNode(name: string): Promise<_AbstractAudioSubNode> {\n        const promise = this._createSubNode(name);\n\n        if (!promise) {\n            return Promise.reject(`Failed to create subnode \"${name}\"`);\n        }\n\n        this._createSubNodePromises[name] = new Promise((resolve, reject) => {\n            promise\n                .then((node) => {\n                    this._addSubNode(node);\n                    resolve(node);\n                })\n                .catch((error) => {\n                    reject(error);\n                });\n        });\n\n        return promise;\n    }\n\n    private _onSubNodeDisposed = (node: AbstractAudioNode) => {\n        const subNode = node as AbstractNamedAudioNode;\n\n        delete this._subNodes[subNode.name];\n\n        this._onSubNodesChanged();\n    };\n}\n", "import { AudioNodeType, AbstractNamedAudioNode } from \"../abstractAudioNode\";\nimport type { AudioEngineV2 } from \"../audioEngineV2\";\n\n/** @internal */\nexport abstract class _AbstractAudioSubNode extends AbstractNamedAudioNode {\n    /** @internal */\n    protected constructor(name: string, engine: AudioEngineV2) {\n        super(name, engine, AudioNodeType.HAS_INPUTS_AND_OUTPUTS);\n    }\n\n    /** @internal */\n    public connect(node: _AbstractAudioSubNode): void {\n        if (!this._connect(node)) {\n            throw new Error(\"Connect failed\");\n        }\n    }\n\n    /** @internal */\n    public disconnect(node: _AbstractAudioSubNode): void {\n        if (!this._disconnect(node)) {\n            throw new Error(\"Disconnect failed\");\n        }\n    }\n\n    /** @internal */\n    public disconnectAll(): void {\n        if (!this._downstreamNodes) {\n            throw new Error(\"Disconnect failed\");\n        }\n\n        const it = this._downstreamNodes.values();\n\n        for (let next = it.next(); !next.done; next = it.next()) {\n            if (!this._disconnect(next.value)) {\n                throw new Error(\"Disconnect failed\");\n            }\n        }\n    }\n}\n", "import type { Nullable } from \"../../../types\";\nimport type { AudioEngineV2 } from \"../audioEngineV2\";\nimport { _AbstractAudioSubNode } from \"../subNodes/abstractAudioSubNode\";\nimport { AudioSubNode } from \"../subNodes/audioSubNode\";\nimport type { _AbstractAudioSubGraph } from \"./abstractAudioSubGraph\";\n\n/** @internal */\nexport const _VolumeAudioDefaults = {\n    volume: 1 as number,\n} as const;\n\n/**\n * Volume options.\n */\nexport interface IVolumeAudioOptions {\n    /**\n     * The volume/gain. Defaults to 1.\n     */\n    volume: number;\n}\n\n/** @internal */\nexport abstract class _VolumeAudioSubNode extends _AbstractAudioSubNode {\n    protected constructor(engine: AudioEngineV2) {\n        super(AudioSubNode.VOLUME, engine);\n    }\n\n    public abstract volume: number;\n\n    /** @internal */\n    public setOptions(options: Partial<IVolumeAudioOptions>): void {\n        this.volume = options.volume ?? _VolumeAudioDefaults.volume;\n    }\n}\n\n/** @internal */\nexport function _GetVolumeAudioSubNode(subGraph: _AbstractAudioSubGraph): Nullable<_VolumeAudioSubNode> {\n    return subGraph.getSubNode<_VolumeAudioSubNode>(AudioSubNode.VOLUME);\n}\n\n/** @internal */\nexport function _GetVolumeAudioProperty<K extends keyof typeof _VolumeAudioDefaults>(subGraph: _AbstractAudioSubGraph, property: K): (typeof _VolumeAudioDefaults)[K] {\n    return _GetVolumeAudioSubNode(subGraph)?.[property] ?? _VolumeAudioDefaults[property];\n}\n", "import { _VolumeAudioSubNode } from \"../../abstractAudio/subNodes/volumeAudioSubNode\";\nimport type { _WebAudioEngine } from \"../webAudioEngine\";\nimport type { IWebAudioInNode, IWebAudioSubNode } from \"../webAudioNode\";\n\n/** @internal */\nexport async function _CreateVolumeAudioSubNodeAsync(engine: _WebAudioEngine): Promise<_VolumeAudioSubNode> {\n    return new _VolumeWebAudioSubNode(engine);\n}\n\n/** @internal */\nexport class _VolumeWebAudioSubNode extends _VolumeAudioSubNode implements IWebAudioSubNode {\n    /** @internal */\n    public readonly node: GainNode;\n\n    /** @internal */\n    public constructor(engine: _WebAudioEngine) {\n        super(engine);\n\n        this.node = new GainNode(engine.audioContext);\n    }\n\n    /** @internal */\n    public get volume(): number {\n        return this.node.gain.value;\n    }\n\n    /** @internal */\n    public set volume(value: number) {\n        this.node.gain.value = value;\n    }\n\n    /** @internal */\n    public get inNode(): AudioNode {\n        return this.node;\n    }\n\n    /** @internal */\n    public get outNode(): AudioNode {\n        return this.node;\n    }\n\n    protected override _connect(node: IWebAudioInNode): boolean {\n        const connected = super._connect(node);\n\n        if (!connected) {\n            return false;\n        }\n\n        // If the wrapped node is not available now, it will be connected later by the subgraph.\n        if (node.inNode) {\n            this.node.connect(node.inNode);\n        }\n\n        return true;\n    }\n\n    protected override _disconnect(node: IWebAudioInNode): boolean {\n        const disconnected = super._disconnect(node);\n\n        if (!disconnected) {\n            return false;\n        }\n\n        if (node.inNode) {\n            this.node.disconnect(node.inNode);\n        }\n\n        return true;\n    }\n\n    /** @internal */\n    public getClassName(): string {\n        return \"_VolumeWebAudioSubNode\";\n    }\n}\n", "import type { Nullable } from \"core/types\";\nimport type { AbstractAudioNode } from \"../../abstractAudio/abstractAudioNode\";\nimport { _AbstractAudioSubGraph } from \"../../abstractAudio/subNodes/abstractAudioSubGraph\";\nimport type { _AbstractAudioSubNode } from \"../../abstractAudio/subNodes/abstractAudioSubNode\";\nimport { AudioSubNode } from \"../../abstractAudio/subNodes/audioSubNode\";\nimport type { IVolumeAudioOptions } from \"../../abstractAudio/subNodes/volumeAudioSubNode\";\nimport { _GetVolumeAudioSubNode } from \"../../abstractAudio/subNodes/volumeAudioSubNode\";\nimport type { IWebAudioInNode, IWebAudioSuperNode } from \"../webAudioNode\";\nimport type { _VolumeWebAudioSubNode } from \"./volumeWebAudioSubNode\";\nimport { _CreateVolumeAudioSubNodeAsync } from \"./volumeWebAudioSubNode\";\n\n/**\n * Options for creating a WebAudioBaseSubGraph.\n */\nexport interface IWebAudioBaseSubGraphOptions extends IVolumeAudioOptions {}\n\n/** @internal */\nexport abstract class _WebAudioBaseSubGraph extends _AbstractAudioSubGraph {\n    protected _owner: IWebAudioSuperNode;\n    protected _outNode: Nullable<AudioNode> = null;\n\n    /** @internal */\n    public constructor(owner: IWebAudioSuperNode) {\n        super();\n\n        this._owner = owner;\n    }\n\n    /** @internal */\n    public async init(options: Partial<IWebAudioBaseSubGraphOptions>): Promise<void> {\n        this._createAndAddSubNode(AudioSubNode.VOLUME);\n        await this._createSubNodePromisesResolved();\n\n        const volumeNode = _GetVolumeAudioSubNode(this);\n        if (!volumeNode) {\n            throw new Error(\"No volume subnode.\");\n        }\n\n        volumeNode.setOptions(options);\n\n        if (volumeNode.getClassName() !== \"_VolumeWebAudioSubNode\") {\n            throw new Error(\"Not a WebAudio subnode.\");\n        }\n\n        this._outNode = (volumeNode as _VolumeWebAudioSubNode).node;\n\n        // Connect the new wrapped WebAudio node to the wrapped downstream WebAudio nodes.\n        // The wrapper nodes are unaware of this change.\n        if (this._outNode && this._downstreamNodes) {\n            const it = this._downstreamNodes.values();\n            for (let next = it.next(); !next.done; next = it.next()) {\n                const inNode = (next.value as IWebAudioInNode).inNode;\n                if (inNode) {\n                    this._outNode.connect(inNode);\n                }\n            }\n        }\n    }\n\n    protected abstract readonly _downstreamNodes: Nullable<Set<AbstractAudioNode>>;\n\n    /** @internal */\n    public get inNode(): Nullable<AudioNode> {\n        return this._outNode;\n    }\n\n    /** @internal */\n    public get outNode(): Nullable<AudioNode> {\n        return this._outNode;\n    }\n\n    protected _createSubNode(name: string): Nullable<Promise<_AbstractAudioSubNode>> {\n        switch (name) {\n            case AudioSubNode.VOLUME:\n                return _CreateVolumeAudioSubNodeAsync(this._owner.engine);\n            default:\n                return null;\n        }\n    }\n}\n"],
  "mappings": "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",
  "names": ["AudioNodeType", "node"]
}
