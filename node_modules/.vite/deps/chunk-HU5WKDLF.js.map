{
  "version": 3,
  "sources": ["../../../dev/core/src/Lights/light.ts", "../../../dev/core/src/Engines/constants.ts", "../../../dev/core/src/Lights/shadowLight.ts", "../../../dev/core/src/Lights/spotLight.ts"],
  "sourcesContent": ["import { serialize, serializeAsColor3, expandToProperty } from \"../Misc/decorators\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { Scene } from \"../scene\";\r\nimport type { Matrix } from \"../Maths/math.vector\";\r\nimport { Vector3 } from \"../Maths/math.vector\";\r\nimport { Color3, TmpColors } from \"../Maths/math.color\";\r\nimport { Node } from \"../node\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport type { Effect } from \"../Materials/effect\";\r\nimport { UniformBuffer } from \"../Materials/uniformBuffer\";\r\nimport type { IShadowGenerator } from \"./Shadows/shadowGenerator\";\r\nimport { GetClass } from \"../Misc/typeStore\";\r\nimport type { ISortableLight } from \"./lightConstants\";\r\nimport { LightConstants } from \"./lightConstants\";\r\nimport type { Camera } from \"../Cameras/camera\";\r\nimport { SerializationHelper } from \"../Misc/decorators.serialization\";\r\n/**\r\n * Base class of all the lights in Babylon. It groups all the generic information about lights.\r\n * Lights are used, as you would expect, to affect how meshes are seen, in terms of both illumination and colour.\r\n * All meshes allow light to pass through them unless shadow generation is activated. The default number of lights allowed is four but this can be increased.\r\n */\r\nexport abstract class Light extends Node implements ISortableLight {\r\n    /**\r\n     * Falloff Default: light is falling off following the material specification:\r\n     * standard material is using standard falloff whereas pbr material can request special falloff per materials.\r\n     */\r\n    public static readonly FALLOFF_DEFAULT = LightConstants.FALLOFF_DEFAULT;\r\n\r\n    /**\r\n     * Falloff Physical: light is falling off following the inverse squared distance law.\r\n     */\r\n    public static readonly FALLOFF_PHYSICAL = LightConstants.FALLOFF_PHYSICAL;\r\n\r\n    /**\r\n     * Falloff gltf: light is falling off as described in the gltf moving to PBR document\r\n     * to enhance interoperability with other engines.\r\n     */\r\n    public static readonly FALLOFF_GLTF = LightConstants.FALLOFF_GLTF;\r\n\r\n    /**\r\n     * Falloff Standard: light is falling off like in the standard material\r\n     * to enhance interoperability with other materials.\r\n     */\r\n    public static readonly FALLOFF_STANDARD = LightConstants.FALLOFF_STANDARD;\r\n\r\n    //lightmapMode Consts\r\n    /**\r\n     * If every light affecting the material is in this lightmapMode,\r\n     * material.lightmapTexture adds or multiplies\r\n     * (depends on material.useLightmapAsShadowmap)\r\n     * after every other light calculations.\r\n     */\r\n    public static readonly LIGHTMAP_DEFAULT = LightConstants.LIGHTMAP_DEFAULT;\r\n    /**\r\n     * material.lightmapTexture as only diffuse lighting from this light\r\n     * adds only specular lighting from this light\r\n     * adds dynamic shadows\r\n     */\r\n    public static readonly LIGHTMAP_SPECULAR = LightConstants.LIGHTMAP_SPECULAR;\r\n    /**\r\n     * material.lightmapTexture as only lighting\r\n     * no light calculation from this light\r\n     * only adds dynamic shadows from this light\r\n     */\r\n    public static readonly LIGHTMAP_SHADOWSONLY = LightConstants.LIGHTMAP_SHADOWSONLY;\r\n\r\n    // Intensity Mode Consts\r\n    /**\r\n     * Each light type uses the default quantity according to its type:\r\n     *      point/spot lights use luminous intensity\r\n     *      directional lights use illuminance\r\n     */\r\n    public static readonly INTENSITYMODE_AUTOMATIC = LightConstants.INTENSITYMODE_AUTOMATIC;\r\n    /**\r\n     * lumen (lm)\r\n     */\r\n    public static readonly INTENSITYMODE_LUMINOUSPOWER = LightConstants.INTENSITYMODE_LUMINOUSPOWER;\r\n    /**\r\n     * candela (lm/sr)\r\n     */\r\n    public static readonly INTENSITYMODE_LUMINOUSINTENSITY = LightConstants.INTENSITYMODE_LUMINOUSINTENSITY;\r\n    /**\r\n     * lux (lm/m^2)\r\n     */\r\n    public static readonly INTENSITYMODE_ILLUMINANCE = LightConstants.INTENSITYMODE_ILLUMINANCE;\r\n    /**\r\n     * nit (cd/m^2)\r\n     */\r\n    public static readonly INTENSITYMODE_LUMINANCE = LightConstants.INTENSITYMODE_LUMINANCE;\r\n\r\n    // Light types ids const.\r\n    /**\r\n     * Light type const id of the point light.\r\n     */\r\n    public static readonly LIGHTTYPEID_POINTLIGHT = LightConstants.LIGHTTYPEID_POINTLIGHT;\r\n    /**\r\n     * Light type const id of the directional light.\r\n     */\r\n    public static readonly LIGHTTYPEID_DIRECTIONALLIGHT = LightConstants.LIGHTTYPEID_DIRECTIONALLIGHT;\r\n    /**\r\n     * Light type const id of the spot light.\r\n     */\r\n    public static readonly LIGHTTYPEID_SPOTLIGHT = LightConstants.LIGHTTYPEID_SPOTLIGHT;\r\n    /**\r\n     * Light type const id of the hemispheric light.\r\n     */\r\n    public static readonly LIGHTTYPEID_HEMISPHERICLIGHT = LightConstants.LIGHTTYPEID_HEMISPHERICLIGHT;\r\n\r\n    /**\r\n     * Light type const id of the area light.\r\n     */\r\n    public static readonly LIGHTTYPEID_RECT_AREALIGHT = LightConstants.LIGHTTYPEID_RECT_AREALIGHT;\r\n\r\n    /**\r\n     * Diffuse gives the basic color to an object.\r\n     */\r\n    @serializeAsColor3()\r\n    public diffuse = new Color3(1.0, 1.0, 1.0);\r\n\r\n    /**\r\n     * Specular produces a highlight color on an object.\r\n     * Note: This is not affecting PBR materials.\r\n     */\r\n    @serializeAsColor3()\r\n    public specular = new Color3(1.0, 1.0, 1.0);\r\n\r\n    /**\r\n     * Defines the falloff type for this light. This lets overriding how punctual light are\r\n     * falling off base on range or angle.\r\n     * This can be set to any values in Light.FALLOFF_x.\r\n     *\r\n     * Note: This is only useful for PBR Materials at the moment. This could be extended if required to\r\n     * other types of materials.\r\n     */\r\n    @serialize()\r\n    public falloffType = Light.FALLOFF_DEFAULT;\r\n\r\n    /**\r\n     * Strength of the light.\r\n     * Note: By default it is define in the framework own unit.\r\n     * Note: In PBR materials the intensityMode can be use to chose what unit the intensity is defined in.\r\n     */\r\n    @serialize()\r\n    public intensity = 1.0;\r\n\r\n    private _range = Number.MAX_VALUE;\r\n    protected _inverseSquaredRange = 0;\r\n\r\n    /**\r\n     * Defines how far from the source the light is impacting in scene units.\r\n     * Note: Unused in PBR material as the distance light falloff is defined following the inverse squared falloff.\r\n     */\r\n    @serialize()\r\n    public get range(): number {\r\n        return this._range;\r\n    }\r\n    /**\r\n     * Defines how far from the source the light is impacting in scene units.\r\n     * Note: Unused in PBR material as the distance light falloff is defined following the inverse squared falloff.\r\n     */\r\n    public set range(value: number) {\r\n        this._range = value;\r\n        this._inverseSquaredRange = 1.0 / (this.range * this.range);\r\n    }\r\n\r\n    /**\r\n     * Cached photometric scale default to 1.0 as the automatic intensity mode defaults to 1.0 for every type\r\n     * of light.\r\n     */\r\n    private _photometricScale = 1.0;\r\n\r\n    private _intensityMode: number = Light.INTENSITYMODE_AUTOMATIC;\r\n    /**\r\n     * Gets the photometric scale used to interpret the intensity.\r\n     * This is only relevant with PBR Materials where the light intensity can be defined in a physical way.\r\n     */\r\n    @serialize()\r\n    public get intensityMode(): number {\r\n        return this._intensityMode;\r\n    }\r\n    /**\r\n     * Sets the photometric scale used to interpret the intensity.\r\n     * This is only relevant with PBR Materials where the light intensity can be defined in a physical way.\r\n     */\r\n    public set intensityMode(value: number) {\r\n        this._intensityMode = value;\r\n        this._computePhotometricScale();\r\n    }\r\n\r\n    private _radius = 0.00001;\r\n    /**\r\n     * Gets the light radius used by PBR Materials to simulate soft area lights.\r\n     */\r\n    @serialize()\r\n    public get radius(): number {\r\n        return this._radius;\r\n    }\r\n    /**\r\n     * sets the light radius used by PBR Materials to simulate soft area lights.\r\n     */\r\n    public set radius(value: number) {\r\n        this._radius = value;\r\n        this._computePhotometricScale();\r\n    }\r\n\r\n    @serialize()\r\n    private _renderPriority: number;\r\n    /**\r\n     * Defines the rendering priority of the lights. It can help in case of fallback or number of lights\r\n     * exceeding the number allowed of the materials.\r\n     */\r\n    @expandToProperty(\"_reorderLightsInScene\")\r\n    public renderPriority: number = 0;\r\n\r\n    @serialize(\"shadowEnabled\")\r\n    private _shadowEnabled: boolean = true;\r\n    /**\r\n     * Gets whether or not the shadows are enabled for this light. This can help turning off/on shadow without detaching\r\n     * the current shadow generator.\r\n     */\r\n    public get shadowEnabled(): boolean {\r\n        return this._shadowEnabled;\r\n    }\r\n    /**\r\n     * Sets whether or not the shadows are enabled for this light. This can help turning off/on shadow without detaching\r\n     * the current shadow generator.\r\n     */\r\n    public set shadowEnabled(value: boolean) {\r\n        if (this._shadowEnabled === value) {\r\n            return;\r\n        }\r\n\r\n        this._shadowEnabled = value;\r\n        this._markMeshesAsLightDirty();\r\n    }\r\n\r\n    private _includedOnlyMeshes: AbstractMesh[];\r\n    /**\r\n     * Gets the only meshes impacted by this light.\r\n     */\r\n    public get includedOnlyMeshes(): AbstractMesh[] {\r\n        return this._includedOnlyMeshes;\r\n    }\r\n    /**\r\n     * Sets the only meshes impacted by this light.\r\n     */\r\n    public set includedOnlyMeshes(value: AbstractMesh[]) {\r\n        this._includedOnlyMeshes = value;\r\n        this._hookArrayForIncludedOnly(value);\r\n    }\r\n\r\n    private _excludedMeshes: AbstractMesh[];\r\n    /**\r\n     * Gets the meshes not impacted by this light.\r\n     */\r\n    public get excludedMeshes(): AbstractMesh[] {\r\n        return this._excludedMeshes;\r\n    }\r\n    /**\r\n     * Sets the meshes not impacted by this light.\r\n     */\r\n    public set excludedMeshes(value: AbstractMesh[]) {\r\n        this._excludedMeshes = value;\r\n        this._hookArrayForExcluded(value);\r\n    }\r\n\r\n    @serialize(\"excludeWithLayerMask\")\r\n    private _excludeWithLayerMask = 0;\r\n    /**\r\n     * Gets the layer id use to find what meshes are not impacted by the light.\r\n     * Inactive if 0\r\n     */\r\n    public get excludeWithLayerMask(): number {\r\n        return this._excludeWithLayerMask;\r\n    }\r\n    /**\r\n     * Sets the layer id use to find what meshes are not impacted by the light.\r\n     * Inactive if 0\r\n     */\r\n    public set excludeWithLayerMask(value: number) {\r\n        this._excludeWithLayerMask = value;\r\n        this._resyncMeshes();\r\n    }\r\n\r\n    @serialize(\"includeOnlyWithLayerMask\")\r\n    private _includeOnlyWithLayerMask = 0;\r\n    /**\r\n     * Gets the layer id use to find what meshes are impacted by the light.\r\n     * Inactive if 0\r\n     */\r\n    public get includeOnlyWithLayerMask(): number {\r\n        return this._includeOnlyWithLayerMask;\r\n    }\r\n    /**\r\n     * Sets the layer id use to find what meshes are impacted by the light.\r\n     * Inactive if 0\r\n     */\r\n    public set includeOnlyWithLayerMask(value: number) {\r\n        this._includeOnlyWithLayerMask = value;\r\n        this._resyncMeshes();\r\n    }\r\n\r\n    @serialize(\"lightmapMode\")\r\n    private _lightmapMode = 0;\r\n    /**\r\n     * Gets the lightmap mode of this light (should be one of the constants defined by Light.LIGHTMAP_x)\r\n     */\r\n    public get lightmapMode(): number {\r\n        return this._lightmapMode;\r\n    }\r\n    /**\r\n     * Sets the lightmap mode of this light (should be one of the constants defined by Light.LIGHTMAP_x)\r\n     */\r\n    public set lightmapMode(value: number) {\r\n        if (this._lightmapMode === value) {\r\n            return;\r\n        }\r\n\r\n        this._lightmapMode = value;\r\n        this._markMeshesAsLightDirty();\r\n    }\r\n\r\n    /**\r\n     * Returns the view matrix.\r\n     * @param _faceIndex The index of the face for which we want to extract the view matrix. Only used for point light types.\r\n     * @returns The view matrix. Can be null, if a view matrix cannot be defined for the type of light considered (as for a hemispherical light, for example).\r\n     */\r\n    public getViewMatrix(_faceIndex?: number): Nullable<Matrix> {\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Returns the projection matrix.\r\n     * Note that viewMatrix and renderList are optional and are only used by lights that calculate the projection matrix from a list of meshes (e.g. directional lights with automatic extents calculation).\r\n     * @param _viewMatrix The view transform matrix of the light (optional).\r\n     * @param _renderList The list of meshes to take into account when calculating the projection matrix (optional).\r\n     * @returns The projection matrix. Can be null, if a projection matrix cannot be defined for the type of light considered (as for a hemispherical light, for example).\r\n     */\r\n    public getProjectionMatrix(_viewMatrix?: Matrix, _renderList?: Array<AbstractMesh>): Nullable<Matrix> {\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Shadow generators associated to the light.\r\n     * @internal Internal use only.\r\n     */\r\n    public _shadowGenerators: Nullable<Map<Nullable<Camera>, IShadowGenerator>> = null;\r\n\r\n    /**\r\n     * @internal Internal use only.\r\n     */\r\n    public _excludedMeshesIds = new Array<string>();\r\n\r\n    /**\r\n     * @internal Internal use only.\r\n     */\r\n    public _includedOnlyMeshesIds = new Array<string>();\r\n\r\n    /**\r\n     * The current light uniform buffer.\r\n     * @internal Internal use only.\r\n     */\r\n    public _uniformBuffer: UniformBuffer;\r\n\r\n    /** @internal */\r\n    public _renderId: number;\r\n\r\n    private _lastUseSpecular: boolean;\r\n\r\n    /**\r\n     * Creates a Light object in the scene.\r\n     * Documentation : https://doc.babylonjs.com/features/featuresDeepDive/lights/lights_introduction\r\n     * @param name The friendly name of the light\r\n     * @param scene The scene the light belongs too\r\n     */\r\n    constructor(name: string, scene?: Scene) {\r\n        super(name, scene, false);\r\n        this.getScene().addLight(this);\r\n        this._uniformBuffer = new UniformBuffer(this.getScene().getEngine(), undefined, undefined, name);\r\n        this._buildUniformLayout();\r\n\r\n        this.includedOnlyMeshes = [] as AbstractMesh[];\r\n        this.excludedMeshes = [] as AbstractMesh[];\r\n\r\n        this._resyncMeshes();\r\n    }\r\n\r\n    protected abstract _buildUniformLayout(): void;\r\n\r\n    /**\r\n     * Sets the passed Effect \"effect\" with the Light information.\r\n     * @param effect The effect to update\r\n     * @param lightIndex The index of the light in the effect to update\r\n     * @returns The light\r\n     */\r\n    public abstract transferToEffect(effect: Effect, lightIndex: string): Light;\r\n\r\n    /**\r\n     * Sets the passed Effect \"effect\" with the Light textures.\r\n     * @param effect The effect to update\r\n     * @param lightIndex The index of the light in the effect to update\r\n     * @returns The light\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public transferTexturesToEffect(effect: Effect, lightIndex: string): Light {\r\n        // Do nothing by default.\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Binds the lights information from the scene to the effect for the given mesh.\r\n     * @param lightIndex Light index\r\n     * @param scene The scene where the light belongs to\r\n     * @param effect The effect we are binding the data to\r\n     * @param useSpecular Defines if specular is supported\r\n     * @param receiveShadows Defines if the effect (mesh) we bind the light for receives shadows\r\n     */\r\n    public _bindLight(lightIndex: number, scene: Scene, effect: Effect, useSpecular: boolean, receiveShadows = true): void {\r\n        const iAsString = lightIndex.toString();\r\n        let needUpdate = false;\r\n\r\n        this._uniformBuffer.bindToEffect(effect, \"Light\" + iAsString);\r\n\r\n        if (this._renderId !== scene.getRenderId() || this._lastUseSpecular !== useSpecular || !this._uniformBuffer.useUbo) {\r\n            this._renderId = scene.getRenderId();\r\n            this._lastUseSpecular = useSpecular;\r\n\r\n            const scaledIntensity = this.getScaledIntensity();\r\n\r\n            this.transferToEffect(effect, iAsString);\r\n\r\n            this.diffuse.scaleToRef(scaledIntensity, TmpColors.Color3[0]);\r\n            this._uniformBuffer.updateColor4(\"vLightDiffuse\", TmpColors.Color3[0], this.range, iAsString);\r\n            if (useSpecular) {\r\n                this.specular.scaleToRef(scaledIntensity, TmpColors.Color3[1]);\r\n                this._uniformBuffer.updateColor4(\"vLightSpecular\", TmpColors.Color3[1], this.radius, iAsString);\r\n            }\r\n            needUpdate = true;\r\n        }\r\n\r\n        // Textures might still need to be rebound.\r\n        this.transferTexturesToEffect(effect, iAsString);\r\n\r\n        // Shadows\r\n        if (scene.shadowsEnabled && this.shadowEnabled && receiveShadows) {\r\n            const shadowGenerator = this.getShadowGenerator(scene.activeCamera) ?? this.getShadowGenerator();\r\n            if (shadowGenerator) {\r\n                shadowGenerator.bindShadowLight(iAsString, effect);\r\n                needUpdate = true;\r\n            }\r\n        }\r\n\r\n        if (needUpdate) {\r\n            this._uniformBuffer.update();\r\n        } else {\r\n            this._uniformBuffer.bindUniformBuffer();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets the passed Effect \"effect\" with the Light information.\r\n     * @param effect The effect to update\r\n     * @param lightDataUniformName The uniform used to store light data (position or direction)\r\n     * @returns The light\r\n     */\r\n    public abstract transferToNodeMaterialEffect(effect: Effect, lightDataUniformName: string): Light;\r\n\r\n    /**\r\n     * Returns the string \"Light\".\r\n     * @returns the class name\r\n     */\r\n    public override getClassName(): string {\r\n        return \"Light\";\r\n    }\r\n\r\n    /** @internal */\r\n    public readonly _isLight = true;\r\n\r\n    /**\r\n     * Converts the light information to a readable string for debug purpose.\r\n     * @param fullDetails Supports for multiple levels of logging within scene loading\r\n     * @returns the human readable light info\r\n     */\r\n    public override toString(fullDetails?: boolean): string {\r\n        let ret = \"Name: \" + this.name;\r\n        ret += \", type: \" + [\"Point\", \"Directional\", \"Spot\", \"Hemispheric\"][this.getTypeID()];\r\n        if (this.animations) {\r\n            for (let i = 0; i < this.animations.length; i++) {\r\n                ret += \", animation[0]: \" + this.animations[i].toString(fullDetails);\r\n            }\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    /** @internal */\r\n    protected override _syncParentEnabledState() {\r\n        super._syncParentEnabledState();\r\n        if (!this.isDisposed()) {\r\n            this._resyncMeshes();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set the enabled state of this node.\r\n     * @param value - the new enabled state\r\n     */\r\n    public override setEnabled(value: boolean): void {\r\n        super.setEnabled(value);\r\n\r\n        this._resyncMeshes();\r\n    }\r\n\r\n    /**\r\n     * Returns the Light associated shadow generator if any.\r\n     * @param camera Camera for which the shadow generator should be retrieved (default: null). If null, retrieves the default shadow generator\r\n     * @returns the associated shadow generator.\r\n     */\r\n    public getShadowGenerator(camera: Nullable<Camera> = null): Nullable<IShadowGenerator> {\r\n        if (this._shadowGenerators === null) {\r\n            return null;\r\n        }\r\n\r\n        return this._shadowGenerators.get(camera) ?? null;\r\n    }\r\n\r\n    /**\r\n     * Returns all the shadow generators associated to this light\r\n     * @returns\r\n     */\r\n    public getShadowGenerators(): Nullable<Map<Nullable<Camera>, IShadowGenerator>> {\r\n        return this._shadowGenerators;\r\n    }\r\n\r\n    /**\r\n     * Returns a Vector3, the absolute light position in the World.\r\n     * @returns the world space position of the light\r\n     */\r\n    public getAbsolutePosition(): Vector3 {\r\n        return Vector3.Zero();\r\n    }\r\n\r\n    /**\r\n     * Specifies if the light will affect the passed mesh.\r\n     * @param mesh The mesh to test against the light\r\n     * @returns true the mesh is affected otherwise, false.\r\n     */\r\n    public canAffectMesh(mesh: AbstractMesh): boolean {\r\n        if (!mesh) {\r\n            return true;\r\n        }\r\n\r\n        if (this.includedOnlyMeshes && this.includedOnlyMeshes.length > 0 && this.includedOnlyMeshes.indexOf(mesh) === -1) {\r\n            return false;\r\n        }\r\n\r\n        if (this.excludedMeshes && this.excludedMeshes.length > 0 && this.excludedMeshes.indexOf(mesh) !== -1) {\r\n            return false;\r\n        }\r\n\r\n        if (this.includeOnlyWithLayerMask !== 0 && (this.includeOnlyWithLayerMask & mesh.layerMask) === 0) {\r\n            return false;\r\n        }\r\n\r\n        if (this.excludeWithLayerMask !== 0 && this.excludeWithLayerMask & mesh.layerMask) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Releases resources associated with this node.\r\n     * @param doNotRecurse Set to true to not recurse into each children (recurse into each children by default)\r\n     * @param disposeMaterialAndTextures Set to true to also dispose referenced materials and textures (false by default)\r\n     */\r\n    public override dispose(doNotRecurse?: boolean, disposeMaterialAndTextures = false): void {\r\n        if (this._shadowGenerators) {\r\n            const iterator = this._shadowGenerators.values();\r\n            for (let key = iterator.next(); key.done !== true; key = iterator.next()) {\r\n                const shadowGenerator = key.value;\r\n                shadowGenerator.dispose();\r\n            }\r\n            this._shadowGenerators = null;\r\n        }\r\n\r\n        // Animations\r\n        this.getScene().stopAnimation(this);\r\n\r\n        if (this._parentContainer) {\r\n            const index = this._parentContainer.lights.indexOf(this);\r\n            if (index > -1) {\r\n                this._parentContainer.lights.splice(index, 1);\r\n            }\r\n            this._parentContainer = null;\r\n        }\r\n\r\n        // Remove from meshes\r\n        for (const mesh of this.getScene().meshes) {\r\n            mesh._removeLightSource(this, true);\r\n        }\r\n\r\n        this._uniformBuffer.dispose();\r\n\r\n        // Remove from scene\r\n        this.getScene().removeLight(this);\r\n        super.dispose(doNotRecurse, disposeMaterialAndTextures);\r\n    }\r\n\r\n    /**\r\n     * Returns the light type ID (integer).\r\n     * @returns The light Type id as a constant defines in Light.LIGHTTYPEID_x\r\n     */\r\n    public getTypeID(): number {\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * Returns the intensity scaled by the Photometric Scale according to the light type and intensity mode.\r\n     * @returns the scaled intensity in intensity mode unit\r\n     */\r\n    public getScaledIntensity() {\r\n        return this._photometricScale * this.intensity;\r\n    }\r\n\r\n    /**\r\n     * Returns a new Light object, named \"name\", from the current one.\r\n     * @param name The name of the cloned light\r\n     * @param newParent The parent of this light, if it has one\r\n     * @returns the new created light\r\n     */\r\n    public override clone(name: string, newParent: Nullable<Node> = null): Nullable<Light> {\r\n        const constructor = Light.GetConstructorFromName(this.getTypeID(), name, this.getScene());\r\n\r\n        if (!constructor) {\r\n            return null;\r\n        }\r\n        const clonedLight = SerializationHelper.Clone(constructor, this);\r\n        if (name) {\r\n            clonedLight.name = name;\r\n        }\r\n        if (newParent) {\r\n            clonedLight.parent = newParent;\r\n        }\r\n        clonedLight.setEnabled(this.isEnabled());\r\n\r\n        this.onClonedObservable.notifyObservers(clonedLight);\r\n\r\n        return clonedLight;\r\n    }\r\n\r\n    /**\r\n     * Serializes the current light into a Serialization object.\r\n     * @returns the serialized object.\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject = SerializationHelper.Serialize(this);\r\n        serializationObject.uniqueId = this.uniqueId;\r\n\r\n        // Type\r\n        serializationObject.type = this.getTypeID();\r\n\r\n        // Parent\r\n        if (this.parent) {\r\n            this.parent._serializeAsParent(serializationObject);\r\n        }\r\n\r\n        // Inclusion / exclusions\r\n        if (this.excludedMeshes.length > 0) {\r\n            serializationObject.excludedMeshesIds = [];\r\n            this.excludedMeshes.forEach((mesh: AbstractMesh) => {\r\n                serializationObject.excludedMeshesIds.push(mesh.id);\r\n            });\r\n        }\r\n\r\n        if (this.includedOnlyMeshes.length > 0) {\r\n            serializationObject.includedOnlyMeshesIds = [];\r\n            this.includedOnlyMeshes.forEach((mesh: AbstractMesh) => {\r\n                serializationObject.includedOnlyMeshesIds.push(mesh.id);\r\n            });\r\n        }\r\n\r\n        // Animations\r\n        SerializationHelper.AppendSerializedAnimations(this, serializationObject);\r\n        serializationObject.ranges = this.serializeAnimationRanges();\r\n\r\n        serializationObject.isEnabled = this.isEnabled();\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Creates a new typed light from the passed type (integer) : point light = 0, directional light = 1, spot light = 2, hemispheric light = 3.\r\n     * This new light is named \"name\" and added to the passed scene.\r\n     * @param type Type according to the types available in Light.LIGHTTYPEID_x\r\n     * @param name The friendly name of the light\r\n     * @param scene The scene the new light will belong to\r\n     * @returns the constructor function\r\n     */\r\n    static GetConstructorFromName(type: number, name: string, scene: Scene): Nullable<() => Light> {\r\n        const constructorFunc = Node.Construct(\"Light_Type_\" + type, name, scene);\r\n\r\n        if (constructorFunc) {\r\n            return <() => Light>constructorFunc;\r\n        }\r\n\r\n        // Default to no light for none present once.\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Parses the passed \"parsedLight\" and returns a new instanced Light from this parsing.\r\n     * @param parsedLight The JSON representation of the light\r\n     * @param scene The scene to create the parsed light in\r\n     * @returns the created light after parsing\r\n     */\r\n    public static Parse(parsedLight: any, scene: Scene): Nullable<Light> {\r\n        const constructor = Light.GetConstructorFromName(parsedLight.type, parsedLight.name, scene);\r\n\r\n        if (!constructor) {\r\n            return null;\r\n        }\r\n\r\n        const light = SerializationHelper.Parse(constructor, parsedLight, scene);\r\n\r\n        // Inclusion / exclusions\r\n        if (parsedLight.excludedMeshesIds) {\r\n            light._excludedMeshesIds = parsedLight.excludedMeshesIds;\r\n        }\r\n\r\n        if (parsedLight.includedOnlyMeshesIds) {\r\n            light._includedOnlyMeshesIds = parsedLight.includedOnlyMeshesIds;\r\n        }\r\n\r\n        // Parent\r\n        if (parsedLight.parentId !== undefined) {\r\n            light._waitingParentId = parsedLight.parentId;\r\n        }\r\n\r\n        if (parsedLight.parentInstanceIndex !== undefined) {\r\n            light._waitingParentInstanceIndex = parsedLight.parentInstanceIndex;\r\n        }\r\n\r\n        // Falloff\r\n        if (parsedLight.falloffType !== undefined) {\r\n            light.falloffType = parsedLight.falloffType;\r\n        }\r\n\r\n        // Lightmaps\r\n        if (parsedLight.lightmapMode !== undefined) {\r\n            light.lightmapMode = parsedLight.lightmapMode;\r\n        }\r\n\r\n        // Animations\r\n        if (parsedLight.animations) {\r\n            for (let animationIndex = 0; animationIndex < parsedLight.animations.length; animationIndex++) {\r\n                const parsedAnimation = parsedLight.animations[animationIndex];\r\n                const internalClass = GetClass(\"BABYLON.Animation\");\r\n                if (internalClass) {\r\n                    light.animations.push(internalClass.Parse(parsedAnimation));\r\n                }\r\n            }\r\n            Node.ParseAnimationRanges(light, parsedLight, scene);\r\n        }\r\n\r\n        if (parsedLight.autoAnimate) {\r\n            scene.beginAnimation(light, parsedLight.autoAnimateFrom, parsedLight.autoAnimateTo, parsedLight.autoAnimateLoop, parsedLight.autoAnimateSpeed || 1.0);\r\n        }\r\n\r\n        // Check if isEnabled is defined to be back compatible with prior serialized versions.\r\n        if (parsedLight.isEnabled !== undefined) {\r\n            light.setEnabled(parsedLight.isEnabled);\r\n        }\r\n\r\n        return light;\r\n    }\r\n\r\n    private _hookArrayForExcluded(array: AbstractMesh[]): void {\r\n        const oldPush = array.push;\r\n        array.push = (...items: AbstractMesh[]) => {\r\n            const result = oldPush.apply(array, items);\r\n\r\n            for (const item of items) {\r\n                item._resyncLightSource(this);\r\n            }\r\n\r\n            return result;\r\n        };\r\n\r\n        const oldSplice = array.splice;\r\n        array.splice = (index: number, deleteCount?: number) => {\r\n            const deleted = oldSplice.apply(array, [index, deleteCount]);\r\n\r\n            for (const item of deleted) {\r\n                item._resyncLightSource(this);\r\n            }\r\n\r\n            return deleted;\r\n        };\r\n\r\n        for (const item of array) {\r\n            item._resyncLightSource(this);\r\n        }\r\n    }\r\n\r\n    private _hookArrayForIncludedOnly(array: AbstractMesh[]): void {\r\n        const oldPush = array.push;\r\n        array.push = (...items: AbstractMesh[]) => {\r\n            const result = oldPush.apply(array, items);\r\n\r\n            this._resyncMeshes();\r\n\r\n            return result;\r\n        };\r\n\r\n        const oldSplice = array.splice;\r\n        array.splice = (index: number, deleteCount?: number) => {\r\n            const deleted = oldSplice.apply(array, [index, deleteCount]);\r\n\r\n            this._resyncMeshes();\r\n\r\n            return deleted;\r\n        };\r\n\r\n        this._resyncMeshes();\r\n    }\r\n\r\n    private _resyncMeshes() {\r\n        for (const mesh of this.getScene().meshes) {\r\n            mesh._resyncLightSource(this);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Forces the meshes to update their light related information in their rendering used effects\r\n     * @internal Internal Use Only\r\n     */\r\n    public _markMeshesAsLightDirty() {\r\n        for (const mesh of this.getScene().meshes) {\r\n            if (mesh.lightSources.indexOf(this) !== -1) {\r\n                mesh._markSubMeshesAsLightDirty();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Recomputes the cached photometric scale if needed.\r\n     */\r\n    private _computePhotometricScale(): void {\r\n        this._photometricScale = this._getPhotometricScale();\r\n        this.getScene().resetCachedMaterial();\r\n    }\r\n\r\n    /**\r\n     * @returns the Photometric Scale according to the light type and intensity mode.\r\n     */\r\n    private _getPhotometricScale() {\r\n        let photometricScale = 0.0;\r\n        const lightTypeID = this.getTypeID();\r\n\r\n        //get photometric mode\r\n        let photometricMode = this.intensityMode;\r\n        if (photometricMode === Light.INTENSITYMODE_AUTOMATIC) {\r\n            if (lightTypeID === Light.LIGHTTYPEID_DIRECTIONALLIGHT) {\r\n                photometricMode = Light.INTENSITYMODE_ILLUMINANCE;\r\n            } else {\r\n                photometricMode = Light.INTENSITYMODE_LUMINOUSINTENSITY;\r\n            }\r\n        }\r\n\r\n        //compute photometric scale\r\n        switch (lightTypeID) {\r\n            case Light.LIGHTTYPEID_POINTLIGHT:\r\n            case Light.LIGHTTYPEID_SPOTLIGHT:\r\n                switch (photometricMode) {\r\n                    case Light.INTENSITYMODE_LUMINOUSPOWER:\r\n                        photometricScale = 1.0 / (4.0 * Math.PI);\r\n                        break;\r\n                    case Light.INTENSITYMODE_LUMINOUSINTENSITY:\r\n                        photometricScale = 1.0;\r\n                        break;\r\n                    case Light.INTENSITYMODE_LUMINANCE:\r\n                        photometricScale = this.radius * this.radius;\r\n                        break;\r\n                }\r\n                break;\r\n\r\n            case Light.LIGHTTYPEID_DIRECTIONALLIGHT:\r\n                switch (photometricMode) {\r\n                    case Light.INTENSITYMODE_ILLUMINANCE:\r\n                        photometricScale = 1.0;\r\n                        break;\r\n                    case Light.INTENSITYMODE_LUMINANCE: {\r\n                        // When radius (and therefore solid angle) is non-zero a directional lights brightness can be specified via central (peak) luminance.\r\n                        // For a directional light the 'radius' defines the angular radius (in radians) rather than world-space radius (e.g. in metres).\r\n                        let apexAngleRadians = this.radius;\r\n                        // Impose a minimum light angular size to avoid the light becoming an infinitely small angular light source (i.e. a dirac delta function).\r\n                        apexAngleRadians = Math.max(apexAngleRadians, 0.001);\r\n                        const solidAngle = 2.0 * Math.PI * (1.0 - Math.cos(apexAngleRadians));\r\n                        photometricScale = solidAngle;\r\n                        break;\r\n                    }\r\n                }\r\n                break;\r\n\r\n            case Light.LIGHTTYPEID_HEMISPHERICLIGHT:\r\n                // No fall off in hemispheric light.\r\n                photometricScale = 1.0;\r\n                break;\r\n        }\r\n        return photometricScale;\r\n    }\r\n\r\n    /**\r\n     * Reorder the light in the scene according to their defined priority.\r\n     * @internal Internal Use Only\r\n     */\r\n    public _reorderLightsInScene(): void {\r\n        const scene = this.getScene();\r\n        if (this._renderPriority != 0) {\r\n            scene.requireLightSorting = true;\r\n        }\r\n        this.getScene().sortLightsByPriority();\r\n    }\r\n\r\n    /**\r\n     * Prepares the list of defines specific to the light type.\r\n     * @param defines the list of defines\r\n     * @param lightIndex defines the index of the light for the effect\r\n     */\r\n    public abstract prepareLightSpecificDefines(defines: any, lightIndex: number): void;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _isReady() {\r\n        return true;\r\n    }\r\n}\r\n", "/* eslint-disable @typescript-eslint/naming-convention */\r\n/** Defines the cross module used constants to avoid circular dependencies */\r\nexport class Constants {\r\n    /** Sampler suffix when associated with a texture name */\r\n    public static readonly AUTOSAMPLERSUFFIX = \"Sampler\";\r\n    /** Flag used to disable diagnostics for WebGPU */\r\n    public static readonly DISABLEUA = \"#define DISABLE_UNIFORMITY_ANALYSIS\";\r\n    /** Defines that alpha blending is disabled */\r\n    public static readonly ALPHA_DISABLE = 0;\r\n    /** Defines that alpha blending is SRC ALPHA * SRC + DEST */\r\n    public static readonly ALPHA_ADD = 1;\r\n    /** Defines that alpha blending is SRC ALPHA * SRC + (1 - SRC ALPHA) * DEST */\r\n    public static readonly ALPHA_COMBINE = 2;\r\n    /** Defines that alpha blending is DEST - SRC * DEST */\r\n    public static readonly ALPHA_SUBTRACT = 3;\r\n    /** Defines that alpha blending is SRC * DEST */\r\n    public static readonly ALPHA_MULTIPLY = 4;\r\n    /** Defines that alpha blending is SRC ALPHA * SRC + (1 - SRC) * DEST */\r\n    public static readonly ALPHA_MAXIMIZED = 5;\r\n    /** Defines that alpha blending is SRC + DEST */\r\n    public static readonly ALPHA_ONEONE = 6;\r\n    /** Defines that alpha blending is SRC + (1 - SRC ALPHA) * DEST */\r\n    public static readonly ALPHA_PREMULTIPLIED = 7;\r\n    /**\r\n     * Defines that alpha blending is SRC + (1 - SRC ALPHA) * DEST\r\n     * Alpha will be set to (1 - SRC ALPHA) * DEST ALPHA\r\n     */\r\n    public static readonly ALPHA_PREMULTIPLIED_PORTERDUFF = 8;\r\n    /** Defines that alpha blending is CST * SRC + (1 - CST) * DEST */\r\n    public static readonly ALPHA_INTERPOLATE = 9;\r\n    /**\r\n     * Defines that alpha blending is SRC + (1 - SRC) * DEST\r\n     * Alpha will be set to SRC ALPHA + (1 - SRC ALPHA) * DEST ALPHA\r\n     */\r\n    public static readonly ALPHA_SCREENMODE = 10;\r\n    /**\r\n     * Defines that alpha blending is SRC + DST\r\n     * Alpha will be set to SRC ALPHA + DST ALPHA\r\n     */\r\n    public static readonly ALPHA_ONEONE_ONEONE = 11;\r\n    /**\r\n     * Defines that alpha blending is SRC * DST ALPHA + DST\r\n     * Alpha will be set to 0\r\n     */\r\n    public static readonly ALPHA_ALPHATOCOLOR = 12;\r\n    /**\r\n     * Defines that alpha blending is SRC * (1 - DST) + DST * (1 - SRC)\r\n     */\r\n    public static readonly ALPHA_REVERSEONEMINUS = 13;\r\n    /**\r\n     * Defines that alpha blending is SRC + DST * (1 - SRC ALPHA)\r\n     * Alpha will be set to SRC ALPHA + DST ALPHA * (1 - SRC ALPHA)\r\n     */\r\n    public static readonly ALPHA_SRC_DSTONEMINUSSRCALPHA = 14;\r\n    /**\r\n     * Defines that alpha blending is SRC + DST\r\n     * Alpha will be set to SRC ALPHA\r\n     */\r\n    public static readonly ALPHA_ONEONE_ONEZERO = 15;\r\n    /**\r\n     * Defines that alpha blending is SRC * (1 - DST) + DST * (1 - SRC)\r\n     * Alpha will be set to DST ALPHA\r\n     */\r\n    public static readonly ALPHA_EXCLUSION = 16;\r\n    /**\r\n     * Defines that alpha blending is SRC * SRC ALPHA + DST * (1 - SRC ALPHA)\r\n     * Alpha will be set to SRC ALPHA + (1 - SRC ALPHA) * DST ALPHA\r\n     */\r\n    public static readonly ALPHA_LAYER_ACCUMULATE = 17;\r\n\r\n    /** Defines that alpha blending equation a SUM */\r\n    public static readonly ALPHA_EQUATION_ADD = 0;\r\n    /** Defines that alpha blending equation a SUBSTRACTION */\r\n    public static readonly ALPHA_EQUATION_SUBSTRACT = 1;\r\n    /** Defines that alpha blending equation a REVERSE SUBSTRACTION */\r\n    public static readonly ALPHA_EQUATION_REVERSE_SUBTRACT = 2;\r\n    /** Defines that alpha blending equation a MAX operation */\r\n    public static readonly ALPHA_EQUATION_MAX = 3;\r\n    /** Defines that alpha blending equation a MIN operation */\r\n    public static readonly ALPHA_EQUATION_MIN = 4;\r\n    /**\r\n     * Defines that alpha blending equation a DARKEN operation:\r\n     * It takes the min of the src and sums the alpha channels.\r\n     */\r\n    public static readonly ALPHA_EQUATION_DARKEN = 5;\r\n\r\n    /** Defines that the resource is not delayed*/\r\n    public static readonly DELAYLOADSTATE_NONE = 0;\r\n    /** Defines that the resource was successfully delay loaded */\r\n    public static readonly DELAYLOADSTATE_LOADED = 1;\r\n    /** Defines that the resource is currently delay loading */\r\n    public static readonly DELAYLOADSTATE_LOADING = 2;\r\n    /** Defines that the resource is delayed and has not started loading */\r\n    public static readonly DELAYLOADSTATE_NOTLOADED = 4;\r\n\r\n    // Depth or Stencil test Constants.\r\n    /** Passed to depthFunction or stencilFunction to specify depth or stencil tests will never pass. i.e. Nothing will be drawn */\r\n    public static readonly NEVER = 0x0200;\r\n    /** Passed to depthFunction or stencilFunction to specify depth or stencil tests will always pass. i.e. Pixels will be drawn in the order they are drawn */\r\n    public static readonly ALWAYS = 0x0207;\r\n    /** Passed to depthFunction or stencilFunction to specify depth or stencil tests will pass if the new depth value is less than the stored value */\r\n    public static readonly LESS = 0x0201;\r\n    /** Passed to depthFunction or stencilFunction to specify depth or stencil tests will pass if the new depth value is equals to the stored value */\r\n    public static readonly EQUAL = 0x0202;\r\n    /** Passed to depthFunction or stencilFunction to specify depth or stencil tests will pass if the new depth value is less than or equal to the stored value */\r\n    public static readonly LEQUAL = 0x0203;\r\n    /** Passed to depthFunction or stencilFunction to specify depth or stencil tests will pass if the new depth value is greater than the stored value */\r\n    public static readonly GREATER = 0x0204;\r\n    /** Passed to depthFunction or stencilFunction to specify depth or stencil tests will pass if the new depth value is greater than or equal to the stored value */\r\n    public static readonly GEQUAL = 0x0206;\r\n    /** Passed to depthFunction or stencilFunction to specify depth or stencil tests will pass if the new depth value is not equal to the stored value */\r\n    public static readonly NOTEQUAL = 0x0205;\r\n\r\n    // Stencil Actions Constants.\r\n    /** Passed to stencilOperation to specify that stencil value must be kept */\r\n    public static readonly KEEP = 0x1e00;\r\n    /** Passed to stencilOperation to specify that stencil value must be zero */\r\n    public static readonly ZERO = 0x0000;\r\n    /** Passed to stencilOperation to specify that stencil value must be replaced */\r\n    public static readonly REPLACE = 0x1e01;\r\n    /** Passed to stencilOperation to specify that stencil value must be incremented */\r\n    public static readonly INCR = 0x1e02;\r\n    /** Passed to stencilOperation to specify that stencil value must be decremented */\r\n    public static readonly DECR = 0x1e03;\r\n    /** Passed to stencilOperation to specify that stencil value must be inverted */\r\n    public static readonly INVERT = 0x150a;\r\n    /** Passed to stencilOperation to specify that stencil value must be incremented with wrapping */\r\n    public static readonly INCR_WRAP = 0x8507;\r\n    /** Passed to stencilOperation to specify that stencil value must be decremented with wrapping */\r\n    public static readonly DECR_WRAP = 0x8508;\r\n\r\n    /** Texture is not repeating outside of 0..1 UVs */\r\n    public static readonly TEXTURE_CLAMP_ADDRESSMODE = 0;\r\n    /** Texture is repeating outside of 0..1 UVs */\r\n    public static readonly TEXTURE_WRAP_ADDRESSMODE = 1;\r\n    /** Texture is repeating and mirrored */\r\n    public static readonly TEXTURE_MIRROR_ADDRESSMODE = 2;\r\n\r\n    /** Flag to create a storage texture */\r\n    public static readonly TEXTURE_CREATIONFLAG_STORAGE = 1;\r\n\r\n    /** ALPHA */\r\n    public static readonly TEXTUREFORMAT_ALPHA = 0;\r\n    /** LUMINANCE */\r\n    public static readonly TEXTUREFORMAT_LUMINANCE = 1;\r\n    /** LUMINANCE_ALPHA */\r\n    public static readonly TEXTUREFORMAT_LUMINANCE_ALPHA = 2;\r\n    /** RGB */\r\n    public static readonly TEXTUREFORMAT_RGB = 4;\r\n    /** RGBA */\r\n    public static readonly TEXTUREFORMAT_RGBA = 5;\r\n    /** RED */\r\n    public static readonly TEXTUREFORMAT_RED = 6;\r\n    /** RED (2nd reference) */\r\n    public static readonly TEXTUREFORMAT_R = 6;\r\n    /** RED unsigned short normed to [0, 1] **/\r\n    public static readonly TEXTUREFORMAT_R16_UNORM = 0x822a;\r\n    /** RG unsigned short normed to [0, 1] **/\r\n    public static readonly TEXTUREFORMAT_RG16_UNORM = 0x822c;\r\n    /** RGB unsigned short normed to [0, 1] **/\r\n    public static readonly TEXTUREFORMAT_RGB16_UNORM = 0x8054;\r\n    /** RGBA unsigned short normed to [0, 1] **/\r\n    public static readonly TEXTUREFORMAT_RGBA16_UNORM = 0x805b;\r\n    /** RED signed short normed to [-1, 1] **/\r\n    public static readonly TEXTUREFORMAT_R16_SNORM = 0x8f98;\r\n    /** RG signed short normed to [-1, 1] **/\r\n    public static readonly TEXTUREFORMAT_RG16_SNORM = 0x8f99;\r\n    /** RGB signed short normed to [-1, 1] **/\r\n    public static readonly TEXTUREFORMAT_RGB16_SNORM = 0x8f9a;\r\n    /** RGBA signed short normed to [-1, 1] **/\r\n    public static readonly TEXTUREFORMAT_RGBA16_SNORM = 0x8f9b;\r\n    /** RG */\r\n    public static readonly TEXTUREFORMAT_RG = 7;\r\n    /** RED_INTEGER */\r\n    public static readonly TEXTUREFORMAT_RED_INTEGER = 8;\r\n    /** RED_INTEGER (2nd reference) */\r\n    public static readonly TEXTUREFORMAT_R_INTEGER = 8;\r\n    /** RG_INTEGER */\r\n    public static readonly TEXTUREFORMAT_RG_INTEGER = 9;\r\n    /** RGB_INTEGER */\r\n    public static readonly TEXTUREFORMAT_RGB_INTEGER = 10;\r\n    /** RGBA_INTEGER */\r\n    public static readonly TEXTUREFORMAT_RGBA_INTEGER = 11;\r\n    /** BGRA */\r\n    public static readonly TEXTUREFORMAT_BGRA = 12;\r\n\r\n    /** Depth 24 bits + Stencil 8 bits */\r\n    public static readonly TEXTUREFORMAT_DEPTH24_STENCIL8 = 13;\r\n    /** Depth 32 bits float */\r\n    public static readonly TEXTUREFORMAT_DEPTH32_FLOAT = 14;\r\n    /** Depth 16 bits */\r\n    public static readonly TEXTUREFORMAT_DEPTH16 = 15;\r\n    /** Depth 24 bits */\r\n    public static readonly TEXTUREFORMAT_DEPTH24 = 16;\r\n    /** Depth 24 bits unorm + Stencil 8 bits */\r\n    public static readonly TEXTUREFORMAT_DEPTH24UNORM_STENCIL8 = 17;\r\n    /** Depth 32 bits float + Stencil 8 bits */\r\n    public static readonly TEXTUREFORMAT_DEPTH32FLOAT_STENCIL8 = 18;\r\n    /** Stencil 8 bits */\r\n    public static readonly TEXTUREFORMAT_STENCIL8 = 19;\r\n    /** UNDEFINED */\r\n    public static readonly TEXTUREFORMAT_UNDEFINED = 0xffffffff;\r\n\r\n    /** Compressed BC7 */\r\n    public static readonly TEXTUREFORMAT_COMPRESSED_RGBA_BPTC_UNORM = 36492;\r\n    /** Compressed BC7 (SRGB) */\r\n    public static readonly TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_BPTC_UNORM = 36493;\r\n    /** Compressed BC6 unsigned float */\r\n    public static readonly TEXTUREFORMAT_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT = 36495;\r\n    /** Compressed BC6 signed float */\r\n    public static readonly TEXTUREFORMAT_COMPRESSED_RGB_BPTC_SIGNED_FLOAT = 36494;\r\n    /** Compressed BC3 */\r\n    public static readonly TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT5 = 33779;\r\n    /** Compressed BC3 (SRGB) */\r\n    public static readonly TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT = 35919;\r\n    /** Compressed BC2 */\r\n    public static readonly TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT3 = 33778;\r\n    /** Compressed BC2 (SRGB) */\r\n    public static readonly TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT = 35918;\r\n    /** Compressed BC1 (RGBA) */\r\n    public static readonly TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT1 = 33777;\r\n    /** Compressed BC1 (RGB) */\r\n    public static readonly TEXTUREFORMAT_COMPRESSED_RGB_S3TC_DXT1 = 33776;\r\n    /** Compressed BC1 (SRGB+A) */\r\n    public static readonly TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT = 35917;\r\n    /** Compressed BC1 (SRGB) */\r\n    public static readonly TEXTUREFORMAT_COMPRESSED_SRGB_S3TC_DXT1_EXT = 35916;\r\n    /** Compressed ASTC 4x4 */\r\n    public static readonly TEXTUREFORMAT_COMPRESSED_RGBA_ASTC_4x4 = 37808;\r\n    /** Compressed ASTC 4x4 (SRGB) */\r\n    public static readonly TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR = 37840;\r\n    /** Compressed ETC1 (RGB) */\r\n    public static readonly TEXTUREFORMAT_COMPRESSED_RGB_ETC1_WEBGL = 36196;\r\n    /** Compressed ETC2 (RGB) */\r\n    public static readonly TEXTUREFORMAT_COMPRESSED_RGB8_ETC2 = 37492;\r\n    /** Compressed ETC2 (SRGB) */\r\n    public static readonly TEXTUREFORMAT_COMPRESSED_SRGB8_ETC2 = 37493;\r\n    /** Compressed ETC2 (RGB+A1) */\r\n    public static readonly TEXTUREFORMAT_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 37494;\r\n    /** Compressed ETC2 (SRGB+A1)*/\r\n    public static readonly TEXTUREFORMAT_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 37495;\r\n    /** Compressed ETC2 (RGB+A) */\r\n    public static readonly TEXTUREFORMAT_COMPRESSED_RGBA8_ETC2_EAC = 37496;\r\n    /** Compressed ETC2 (SRGB+1) */\r\n    public static readonly TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC = 37497;\r\n\r\n    /** UNSIGNED_BYTE */\r\n    public static readonly TEXTURETYPE_UNSIGNED_BYTE = 0;\r\n    /** @deprecated use more explicit TEXTURETYPE_UNSIGNED_BYTE instead. Use TEXTURETYPE_UNSIGNED_INTEGER for 32bits values.*/\r\n    public static readonly TEXTURETYPE_UNSIGNED_INT = 0;\r\n    /** FLOAT */\r\n    public static readonly TEXTURETYPE_FLOAT = 1;\r\n    /** HALF_FLOAT */\r\n    public static readonly TEXTURETYPE_HALF_FLOAT = 2;\r\n    /** BYTE */\r\n    public static readonly TEXTURETYPE_BYTE = 3;\r\n    /** SHORT */\r\n    public static readonly TEXTURETYPE_SHORT = 4;\r\n    /** UNSIGNED_SHORT */\r\n    public static readonly TEXTURETYPE_UNSIGNED_SHORT = 5;\r\n    /** INT */\r\n    public static readonly TEXTURETYPE_INT = 6;\r\n    /** UNSIGNED_INT */\r\n    public static readonly TEXTURETYPE_UNSIGNED_INTEGER = 7;\r\n    /** UNSIGNED_SHORT_4_4_4_4 */\r\n    public static readonly TEXTURETYPE_UNSIGNED_SHORT_4_4_4_4 = 8;\r\n    /** UNSIGNED_SHORT_5_5_5_1 */\r\n    public static readonly TEXTURETYPE_UNSIGNED_SHORT_5_5_5_1 = 9;\r\n    /** UNSIGNED_SHORT_5_6_5 */\r\n    public static readonly TEXTURETYPE_UNSIGNED_SHORT_5_6_5 = 10;\r\n    /** UNSIGNED_INT_2_10_10_10_REV */\r\n    public static readonly TEXTURETYPE_UNSIGNED_INT_2_10_10_10_REV = 11;\r\n    /** UNSIGNED_INT_24_8 */\r\n    public static readonly TEXTURETYPE_UNSIGNED_INT_24_8 = 12;\r\n    /** UNSIGNED_INT_10F_11F_11F_REV */\r\n    public static readonly TEXTURETYPE_UNSIGNED_INT_10F_11F_11F_REV = 13;\r\n    /** UNSIGNED_INT_5_9_9_9_REV */\r\n    public static readonly TEXTURETYPE_UNSIGNED_INT_5_9_9_9_REV = 14;\r\n    /** FLOAT_32_UNSIGNED_INT_24_8_REV */\r\n    public static readonly TEXTURETYPE_FLOAT_32_UNSIGNED_INT_24_8_REV = 15;\r\n    /** UNDEFINED */\r\n    public static readonly TEXTURETYPE_UNDEFINED = 16;\r\n\r\n    /** 2D Texture target*/\r\n    public static readonly TEXTURE_2D = 3553;\r\n    /** 2D Array Texture target */\r\n    public static readonly TEXTURE_2D_ARRAY = 35866;\r\n    /** Cube Map Texture target */\r\n    public static readonly TEXTURE_CUBE_MAP = 34067;\r\n    /** Cube Map Array Texture target */\r\n    public static readonly TEXTURE_CUBE_MAP_ARRAY = 0xdeadbeef;\r\n    /** 3D Texture target */\r\n    public static readonly TEXTURE_3D = 32879;\r\n\r\n    /** nearest is mag = nearest and min = nearest and no mip */\r\n    public static readonly TEXTURE_NEAREST_SAMPLINGMODE = 1;\r\n    /** mag = nearest and min = nearest and mip = none */\r\n    public static readonly TEXTURE_NEAREST_NEAREST = 1;\r\n\r\n    /** Bilinear is mag = linear and min = linear and no mip */\r\n    public static readonly TEXTURE_BILINEAR_SAMPLINGMODE = 2;\r\n    /** mag = linear and min = linear and mip = none */\r\n    public static readonly TEXTURE_LINEAR_LINEAR = 2;\r\n\r\n    /** Trilinear is mag = linear and min = linear and mip = linear */\r\n    public static readonly TEXTURE_TRILINEAR_SAMPLINGMODE = 3;\r\n    /** Trilinear is mag = linear and min = linear and mip = linear */\r\n    public static readonly TEXTURE_LINEAR_LINEAR_MIPLINEAR = 3;\r\n\r\n    /** mag = nearest and min = nearest and mip = nearest */\r\n    public static readonly TEXTURE_NEAREST_NEAREST_MIPNEAREST = 4;\r\n    /** mag = nearest and min = linear and mip = nearest */\r\n    public static readonly TEXTURE_NEAREST_LINEAR_MIPNEAREST = 5;\r\n    /** mag = nearest and min = linear and mip = linear */\r\n    public static readonly TEXTURE_NEAREST_LINEAR_MIPLINEAR = 6;\r\n    /** mag = nearest and min = linear and mip = none */\r\n    public static readonly TEXTURE_NEAREST_LINEAR = 7;\r\n    /** nearest is mag = nearest and min = nearest and mip = linear */\r\n    public static readonly TEXTURE_NEAREST_NEAREST_MIPLINEAR = 8;\r\n    /** mag = linear and min = nearest and mip = nearest */\r\n    public static readonly TEXTURE_LINEAR_NEAREST_MIPNEAREST = 9;\r\n    /** mag = linear and min = nearest and mip = linear */\r\n    public static readonly TEXTURE_LINEAR_NEAREST_MIPLINEAR = 10;\r\n    /** Bilinear is mag = linear and min = linear and mip = nearest */\r\n    public static readonly TEXTURE_LINEAR_LINEAR_MIPNEAREST = 11;\r\n    /** mag = linear and min = nearest and mip = none */\r\n    public static readonly TEXTURE_LINEAR_NEAREST = 12;\r\n\r\n    /** Explicit coordinates mode */\r\n    public static readonly TEXTURE_EXPLICIT_MODE = 0;\r\n    /** Spherical coordinates mode */\r\n    public static readonly TEXTURE_SPHERICAL_MODE = 1;\r\n    /** Planar coordinates mode */\r\n    public static readonly TEXTURE_PLANAR_MODE = 2;\r\n    /** Cubic coordinates mode */\r\n    public static readonly TEXTURE_CUBIC_MODE = 3;\r\n    /** Projection coordinates mode */\r\n    public static readonly TEXTURE_PROJECTION_MODE = 4;\r\n    /** Skybox coordinates mode */\r\n    public static readonly TEXTURE_SKYBOX_MODE = 5;\r\n    /** Inverse Cubic coordinates mode */\r\n    public static readonly TEXTURE_INVCUBIC_MODE = 6;\r\n    /** Equirectangular coordinates mode */\r\n    public static readonly TEXTURE_EQUIRECTANGULAR_MODE = 7;\r\n    /** Equirectangular Fixed coordinates mode */\r\n    public static readonly TEXTURE_FIXED_EQUIRECTANGULAR_MODE = 8;\r\n    /** Equirectangular Fixed Mirrored coordinates mode */\r\n    public static readonly TEXTURE_FIXED_EQUIRECTANGULAR_MIRRORED_MODE = 9;\r\n\r\n    /** Offline (baking) quality for texture filtering */\r\n    public static readonly TEXTURE_FILTERING_QUALITY_OFFLINE = 4096;\r\n\r\n    /** High quality for texture filtering */\r\n    public static readonly TEXTURE_FILTERING_QUALITY_HIGH = 64;\r\n\r\n    /** Medium quality for texture filtering */\r\n    public static readonly TEXTURE_FILTERING_QUALITY_MEDIUM = 16;\r\n\r\n    /** Low quality for texture filtering */\r\n    public static readonly TEXTURE_FILTERING_QUALITY_LOW = 8;\r\n\r\n    // Texture rescaling mode\r\n    /** Defines that texture rescaling will use a floor to find the closer power of 2 size */\r\n    public static readonly SCALEMODE_FLOOR = 1;\r\n    /** Defines that texture rescaling will look for the nearest power of 2 size */\r\n    public static readonly SCALEMODE_NEAREST = 2;\r\n    /** Defines that texture rescaling will use a ceil to find the closer power of 2 size */\r\n    public static readonly SCALEMODE_CEILING = 3;\r\n\r\n    /**\r\n     * The dirty texture flag value\r\n     */\r\n    public static readonly MATERIAL_TextureDirtyFlag = 1;\r\n    /**\r\n     * The dirty light flag value\r\n     */\r\n    public static readonly MATERIAL_LightDirtyFlag = 2;\r\n    /**\r\n     * The dirty fresnel flag value\r\n     */\r\n    public static readonly MATERIAL_FresnelDirtyFlag = 4;\r\n    /**\r\n     * The dirty attribute flag value\r\n     */\r\n    public static readonly MATERIAL_AttributesDirtyFlag = 8;\r\n    /**\r\n     * The dirty misc flag value\r\n     */\r\n    public static readonly MATERIAL_MiscDirtyFlag = 16;\r\n    /**\r\n     * The dirty prepass flag value\r\n     */\r\n    public static readonly MATERIAL_PrePassDirtyFlag = 32;\r\n    /**\r\n     * The all dirty flag value\r\n     */\r\n    public static readonly MATERIAL_AllDirtyFlag = 63;\r\n\r\n    /**\r\n     * Returns the triangle fill mode\r\n     */\r\n    public static readonly MATERIAL_TriangleFillMode = 0;\r\n    /**\r\n     * Returns the wireframe mode\r\n     */\r\n    public static readonly MATERIAL_WireFrameFillMode = 1;\r\n    /**\r\n     * Returns the point fill mode\r\n     */\r\n    public static readonly MATERIAL_PointFillMode = 2;\r\n    /**\r\n     * Returns the point list draw mode\r\n     */\r\n    public static readonly MATERIAL_PointListDrawMode = 3;\r\n    /**\r\n     * Returns the line list draw mode\r\n     */\r\n    public static readonly MATERIAL_LineListDrawMode = 4;\r\n    /**\r\n     * Returns the line loop draw mode\r\n     */\r\n    public static readonly MATERIAL_LineLoopDrawMode = 5;\r\n    /**\r\n     * Returns the line strip draw mode\r\n     */\r\n    public static readonly MATERIAL_LineStripDrawMode = 6;\r\n\r\n    /**\r\n     * Returns the triangle strip draw mode\r\n     */\r\n    public static readonly MATERIAL_TriangleStripDrawMode = 7;\r\n    /**\r\n     * Returns the triangle fan draw mode\r\n     */\r\n    public static readonly MATERIAL_TriangleFanDrawMode = 8;\r\n\r\n    /**\r\n     * Stores the clock-wise side orientation\r\n     */\r\n    public static readonly MATERIAL_ClockWiseSideOrientation = 0;\r\n    /**\r\n     * Stores the counter clock-wise side orientation\r\n     */\r\n    public static readonly MATERIAL_CounterClockWiseSideOrientation = 1;\r\n\r\n    /**\r\n     * Nothing\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/events/actions#triggers\r\n     */\r\n    public static readonly ACTION_NothingTrigger = 0;\r\n    /**\r\n     * On pick\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/events/actions#triggers\r\n     */\r\n    public static readonly ACTION_OnPickTrigger = 1;\r\n    /**\r\n     * On left pick\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/events/actions#triggers\r\n     */\r\n    public static readonly ACTION_OnLeftPickTrigger = 2;\r\n    /**\r\n     * On right pick\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/events/actions#triggers\r\n     */\r\n    public static readonly ACTION_OnRightPickTrigger = 3;\r\n    /**\r\n     * On center pick\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/events/actions#triggers\r\n     */\r\n    public static readonly ACTION_OnCenterPickTrigger = 4;\r\n    /**\r\n     * On pick down\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/events/actions#triggers\r\n     */\r\n    public static readonly ACTION_OnPickDownTrigger = 5;\r\n    /**\r\n     * On double pick\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/events/actions#triggers\r\n     */\r\n    public static readonly ACTION_OnDoublePickTrigger = 6;\r\n    /**\r\n     * On pick up\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/events/actions#triggers\r\n     */\r\n    public static readonly ACTION_OnPickUpTrigger = 7;\r\n    /**\r\n     * On pick out.\r\n     * This trigger will only be raised if you also declared a OnPickDown\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/events/actions#triggers\r\n     */\r\n    public static readonly ACTION_OnPickOutTrigger = 16;\r\n    /**\r\n     * On long press\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/events/actions#triggers\r\n     */\r\n    public static readonly ACTION_OnLongPressTrigger = 8;\r\n    /**\r\n     * On pointer over\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/events/actions#triggers\r\n     */\r\n    public static readonly ACTION_OnPointerOverTrigger = 9;\r\n    /**\r\n     * On pointer out\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/events/actions#triggers\r\n     */\r\n    public static readonly ACTION_OnPointerOutTrigger = 10;\r\n    /**\r\n     * On every frame\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/events/actions#triggers\r\n     */\r\n    public static readonly ACTION_OnEveryFrameTrigger = 11;\r\n    /**\r\n     * On intersection enter\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/events/actions#triggers\r\n     */\r\n    public static readonly ACTION_OnIntersectionEnterTrigger = 12;\r\n    /**\r\n     * On intersection exit\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/events/actions#triggers\r\n     */\r\n    public static readonly ACTION_OnIntersectionExitTrigger = 13;\r\n    /**\r\n     * On key down\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/events/actions#triggers\r\n     */\r\n    public static readonly ACTION_OnKeyDownTrigger = 14;\r\n    /**\r\n     * On key up\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/events/actions#triggers\r\n     */\r\n    public static readonly ACTION_OnKeyUpTrigger = 15;\r\n\r\n    /**\r\n     * Billboard mode will only apply to Y axis\r\n     */\r\n    public static readonly PARTICLES_BILLBOARDMODE_Y = 2;\r\n    /**\r\n     * Billboard mode will apply to all axes\r\n     */\r\n    public static readonly PARTICLES_BILLBOARDMODE_ALL = 7;\r\n    /**\r\n     * Special billboard mode where the particle will be biilboard to the camera but rotated to align with direction\r\n     */\r\n    public static readonly PARTICLES_BILLBOARDMODE_STRETCHED = 8;\r\n    /**\r\n     * Special billboard mode where the particle will be billboard to the camera but only around the axis of the direction of particle emission\r\n     */\r\n    public static readonly PARTICLES_BILLBOARDMODE_STRETCHED_LOCAL = 9;\r\n\r\n    /** Default culling strategy : this is an exclusion test and it's the more accurate.\r\n     *  Test order :\r\n     *  Is the bounding sphere outside the frustum ?\r\n     *  If not, are the bounding box vertices outside the frustum ?\r\n     *  It not, then the cullable object is in the frustum.\r\n     */\r\n    public static readonly MESHES_CULLINGSTRATEGY_STANDARD = 0;\r\n    /** Culling strategy : Bounding Sphere Only.\r\n     *  This is an exclusion test. It's faster than the standard strategy because the bounding box is not tested.\r\n     *  It's also less accurate than the standard because some not visible objects can still be selected.\r\n     *  Test : is the bounding sphere outside the frustum ?\r\n     *  If not, then the cullable object is in the frustum.\r\n     */\r\n    public static readonly MESHES_CULLINGSTRATEGY_BOUNDINGSPHERE_ONLY = 1;\r\n    /** Culling strategy : Optimistic Inclusion.\r\n     *  This in an inclusion test first, then the standard exclusion test.\r\n     *  This can be faster when a cullable object is expected to be almost always in the camera frustum.\r\n     *  This could also be a little slower than the standard test when the tested object center is not the frustum but one of its bounding box vertex is still inside.\r\n     *  Anyway, it's as accurate as the standard strategy.\r\n     *  Test :\r\n     *  Is the cullable object bounding sphere center in the frustum ?\r\n     *  If not, apply the default culling strategy.\r\n     */\r\n    public static readonly MESHES_CULLINGSTRATEGY_OPTIMISTIC_INCLUSION = 2;\r\n    /** Culling strategy : Optimistic Inclusion then Bounding Sphere Only.\r\n     *  This in an inclusion test first, then the bounding sphere only exclusion test.\r\n     *  This can be the fastest test when a cullable object is expected to be almost always in the camera frustum.\r\n     *  This could also be a little slower than the BoundingSphereOnly strategy when the tested object center is not in the frustum but its bounding sphere still intersects it.\r\n     *  It's less accurate than the standard strategy and as accurate as the BoundingSphereOnly strategy.\r\n     *  Test :\r\n     *  Is the cullable object bounding sphere center in the frustum ?\r\n     *  If not, apply the Bounding Sphere Only strategy. No Bounding Box is tested here.\r\n     */\r\n    public static readonly MESHES_CULLINGSTRATEGY_OPTIMISTIC_INCLUSION_THEN_BSPHERE_ONLY = 3;\r\n\r\n    /**\r\n     * No logging while loading\r\n     */\r\n    public static readonly SCENELOADER_NO_LOGGING = 0;\r\n    /**\r\n     * Minimal logging while loading\r\n     */\r\n    public static readonly SCENELOADER_MINIMAL_LOGGING = 1;\r\n    /**\r\n     * Summary logging while loading\r\n     */\r\n    public static readonly SCENELOADER_SUMMARY_LOGGING = 2;\r\n    /**\r\n     * Detailed logging while loading\r\n     */\r\n    public static readonly SCENELOADER_DETAILED_LOGGING = 3;\r\n\r\n    /**\r\n     * Constant used to retrieve the irradiance texture index in the textures array in the prepass\r\n     * using getIndex(Constants.PREPASS_IRRADIANCE_TEXTURE_TYPE)\r\n     */\r\n    public static readonly PREPASS_IRRADIANCE_TEXTURE_TYPE = 0;\r\n    /**\r\n     * Constant used to retrieve the position texture index in the textures array in the prepass\r\n     * using getIndex(Constants.PREPASS_POSITION_TEXTURE_INDEX)\r\n     */\r\n    public static readonly PREPASS_POSITION_TEXTURE_TYPE = 1;\r\n    /**\r\n     * Constant used to retrieve the velocity texture index in the textures array in the prepass\r\n     * using getIndex(Constants.PREPASS_VELOCITY_TEXTURE_TYPE)\r\n     */\r\n    public static readonly PREPASS_VELOCITY_TEXTURE_TYPE = 2;\r\n    /**\r\n     * Constant used to retrieve the reflectivity texture index in the textures array in the prepass\r\n     * using the getIndex(Constants.PREPASS_REFLECTIVITY_TEXTURE_TYPE)\r\n     */\r\n    public static readonly PREPASS_REFLECTIVITY_TEXTURE_TYPE = 3;\r\n    /**\r\n     * Constant used to retrieve the lit color texture index in the textures array in the prepass\r\n     * using the getIndex(Constants.PREPASS_COLOR_TEXTURE_TYPE)\r\n     */\r\n    public static readonly PREPASS_COLOR_TEXTURE_TYPE = 4;\r\n    /**\r\n     * Constant used to retrieve depth index in the textures array in the prepass\r\n     * using the getIndex(Constants.PREPASS_DEPTH_TEXTURE_TYPE)\r\n     */\r\n    public static readonly PREPASS_DEPTH_TEXTURE_TYPE = 5;\r\n    /**\r\n     * Constant used to retrieve normal index in the textures array in the prepass\r\n     * using the getIndex(Constants.PREPASS_NORMAL_TEXTURE_TYPE)\r\n     */\r\n    public static readonly PREPASS_NORMAL_TEXTURE_TYPE = 6;\r\n    /**\r\n     * Constant used to retrieve (sqrt) albedo index in the textures array in the prepass\r\n     * using the getIndex(Constants.PREPASS_ALBEDO_SQRT_TEXTURE_TYPE)\r\n     */\r\n    public static readonly PREPASS_ALBEDO_SQRT_TEXTURE_TYPE = 7;\r\n\r\n    /**\r\n     * Constant used to retrieve world normal index in the textures array in the prepass\r\n     * using the getIndex(Constants.PREPASS_WORLD_NORMAL_TEXTURE_TYPE)\r\n     */\r\n    public static readonly PREPASS_WORLD_NORMAL_TEXTURE_TYPE = 8;\r\n\r\n    /**\r\n     * Constant used to retrieve the local position texture index in the textures array in the prepass\r\n     * using getIndex(Constants.PREPASS_LOCAL_POSITION_TEXTURE_TYPE)\r\n     */\r\n    public static readonly PREPASS_LOCAL_POSITION_TEXTURE_TYPE = 9;\r\n\r\n    /**\r\n     * Constant used to retrieve screen-space (non-linear) depth index in the textures array in the prepass\r\n     * using the getIndex(Constants.PREPASS_SCREENSPACE_DEPTH_TEXTURE_TYPE)\r\n     */\r\n    public static readonly PREPASS_SCREENSPACE_DEPTH_TEXTURE_TYPE = 10;\r\n\r\n    /**\r\n     * Constant used to retrieve the velocity texture index in the textures array in the prepass\r\n     * using getIndex(Constants.PREPASS_VELOCITY_LINEAR_TEXTURE_TYPE)\r\n     */\r\n    public static readonly PREPASS_VELOCITY_LINEAR_TEXTURE_TYPE = 11;\r\n\r\n    /**\r\n     * Constant used to retrieve albedo index in the textures array in the prepass\r\n     * using the getIndex(Constants.PREPASS_ALBEDO_TEXTURE_TYPE)\r\n     */\r\n    public static readonly PREPASS_ALBEDO_TEXTURE_TYPE = 12;\r\n\r\n    /** Flag to create a readable buffer (the buffer can be the source of a copy) */\r\n    public static readonly BUFFER_CREATIONFLAG_READ = 1;\r\n    /** Flag to create a writable buffer (the buffer can be the destination of a copy) */\r\n    public static readonly BUFFER_CREATIONFLAG_WRITE = 2;\r\n    /** Flag to create a readable and writable buffer */\r\n    public static readonly BUFFER_CREATIONFLAG_READWRITE = 3;\r\n    /** Flag to create a buffer suitable to be used as a uniform buffer */\r\n    public static readonly BUFFER_CREATIONFLAG_UNIFORM = 4;\r\n    /** Flag to create a buffer suitable to be used as a vertex buffer */\r\n    public static readonly BUFFER_CREATIONFLAG_VERTEX = 8;\r\n    /** Flag to create a buffer suitable to be used as an index buffer */\r\n    public static readonly BUFFER_CREATIONFLAG_INDEX = 16;\r\n    /** Flag to create a buffer suitable to be used as a storage buffer */\r\n    public static readonly BUFFER_CREATIONFLAG_STORAGE = 32;\r\n    /** Flag to create a buffer suitable to be used for indirect calls, such as `dispatchIndirect` */\r\n    public static readonly BUFFER_CREATIONFLAG_INDIRECT = 64;\r\n\r\n    /**\r\n     * Prefixes used by the engine for sub mesh draw wrappers\r\n     */\r\n\r\n    /** @internal */\r\n    public static readonly RENDERPASS_MAIN = 0;\r\n\r\n    /**\r\n     * Constant used as key code for Alt key\r\n     */\r\n    public static readonly INPUT_ALT_KEY = 18;\r\n\r\n    /**\r\n     * Constant used as key code for Ctrl key\r\n     */\r\n    public static readonly INPUT_CTRL_KEY = 17;\r\n\r\n    /**\r\n     * Constant used as key code for Meta key (Left Win, Left Cmd)\r\n     */\r\n    public static readonly INPUT_META_KEY1 = 91;\r\n\r\n    /**\r\n     * Constant used as key code for Meta key (Right Win)\r\n     */\r\n    public static readonly INPUT_META_KEY2 = 92;\r\n\r\n    /**\r\n     * Constant used as key code for Meta key (Right Win, Right Cmd)\r\n     */\r\n    public static readonly INPUT_META_KEY3 = 93;\r\n\r\n    /**\r\n     * Constant used as key code for Shift key\r\n     */\r\n    public static readonly INPUT_SHIFT_KEY = 16;\r\n\r\n    /** Standard snapshot rendering. In this mode, some form of dynamic behavior is possible (for eg, uniform buffers are still updated) */\r\n    public static readonly SNAPSHOTRENDERING_STANDARD = 0;\r\n\r\n    /** Fast snapshot rendering. In this mode, everything is static and only some limited form of dynamic behaviour is possible */\r\n    public static readonly SNAPSHOTRENDERING_FAST = 1;\r\n\r\n    /**\r\n     * This is the default projection mode used by the cameras.\r\n     * It helps recreating a feeling of perspective and better appreciate depth.\r\n     * This is the best way to simulate real life cameras.\r\n     */\r\n    public static readonly PERSPECTIVE_CAMERA = 0;\r\n    /**\r\n     * This helps creating camera with an orthographic mode.\r\n     * Orthographic is commonly used in engineering as a means to produce object specifications that communicate dimensions unambiguously, each line of 1 unit length (cm, meter..whatever) will appear to have the same length everywhere on the drawing. This allows the drafter to dimension only a subset of lines and let the reader know that other lines of that length on the drawing are also that length in reality. Every parallel line in the drawing is also parallel in the object.\r\n     */\r\n    public static readonly ORTHOGRAPHIC_CAMERA = 1;\r\n\r\n    /**\r\n     * This is the default FOV mode for perspective cameras.\r\n     * This setting aligns the upper and lower bounds of the viewport to the upper and lower bounds of the camera frustum.\r\n     */\r\n    public static readonly FOVMODE_VERTICAL_FIXED = 0;\r\n    /**\r\n     * This setting aligns the left and right bounds of the viewport to the left and right bounds of the camera frustum.\r\n     */\r\n    public static readonly FOVMODE_HORIZONTAL_FIXED = 1;\r\n\r\n    /**\r\n     * This specifies there is no need for a camera rig.\r\n     * Basically only one eye is rendered corresponding to the camera.\r\n     */\r\n    public static readonly RIG_MODE_NONE = 0;\r\n    /**\r\n     * Simulates a camera Rig with one blue eye and one red eye.\r\n     * This can be use with 3d blue and red glasses.\r\n     */\r\n    public static readonly RIG_MODE_STEREOSCOPIC_ANAGLYPH = 10;\r\n    /**\r\n     * Defines that both eyes of the camera will be rendered side by side with a parallel target.\r\n     */\r\n    public static readonly RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL = 11;\r\n    /**\r\n     * Defines that both eyes of the camera will be rendered side by side with a none parallel target.\r\n     */\r\n    public static readonly RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED = 12;\r\n    /**\r\n     * Defines that both eyes of the camera will be rendered over under each other.\r\n     */\r\n    public static readonly RIG_MODE_STEREOSCOPIC_OVERUNDER = 13;\r\n    /**\r\n     * Defines that both eyes of the camera will be rendered on successive lines interlaced for passive 3d monitors.\r\n     */\r\n    public static readonly RIG_MODE_STEREOSCOPIC_INTERLACED = 14;\r\n    /**\r\n     * Defines that both eyes of the camera should be renderered in a VR mode (carbox).\r\n     */\r\n    public static readonly RIG_MODE_VR = 20;\r\n    /**\r\n     * Custom rig mode allowing rig cameras to be populated manually with any number of cameras\r\n     */\r\n    public static readonly RIG_MODE_CUSTOM = 22;\r\n\r\n    /**\r\n     * Maximum number of uv sets supported\r\n     */\r\n    public static readonly MAX_SUPPORTED_UV_SETS = 6;\r\n\r\n    /**\r\n     * GL constants\r\n     */\r\n    /** Alpha blend equation: ADD */\r\n    public static readonly GL_ALPHA_EQUATION_ADD = 0x8006;\r\n    /** Alpha equation: MIN */\r\n    public static readonly GL_ALPHA_EQUATION_MIN = 0x8007;\r\n    /** Alpha equation: MAX */\r\n    public static readonly GL_ALPHA_EQUATION_MAX = 0x8008;\r\n    /** Alpha equation: SUBTRACT */\r\n    public static readonly GL_ALPHA_EQUATION_SUBTRACT = 0x800a;\r\n    /** Alpha equation: REVERSE_SUBTRACT */\r\n    public static readonly GL_ALPHA_EQUATION_REVERSE_SUBTRACT = 0x800b;\r\n\r\n    /** Alpha blend function: SRC */\r\n    public static readonly GL_ALPHA_FUNCTION_SRC = 0x0300;\r\n    /** Alpha blend function: ONE_MINUS_SRC */\r\n    public static readonly GL_ALPHA_FUNCTION_ONE_MINUS_SRC_COLOR = 0x0301;\r\n    /** Alpha blend function: SRC_ALPHA */\r\n    public static readonly GL_ALPHA_FUNCTION_SRC_ALPHA = 0x0302;\r\n    /** Alpha blend function: ONE_MINUS_SRC_ALPHA */\r\n    public static readonly GL_ALPHA_FUNCTION_ONE_MINUS_SRC_ALPHA = 0x0303;\r\n    /** Alpha blend function: DST_ALPHA */\r\n    public static readonly GL_ALPHA_FUNCTION_DST_ALPHA = 0x0304;\r\n    /** Alpha blend function: ONE_MINUS_DST_ALPHA */\r\n    public static readonly GL_ALPHA_FUNCTION_ONE_MINUS_DST_ALPHA = 0x0305;\r\n    /** Alpha blend function: ONE_MINUS_DST */\r\n    public static readonly GL_ALPHA_FUNCTION_DST_COLOR = 0x0306;\r\n    /** Alpha blend function: ONE_MINUS_DST */\r\n    public static readonly GL_ALPHA_FUNCTION_ONE_MINUS_DST_COLOR = 0x0307;\r\n    /** Alpha blend function: SRC_ALPHA_SATURATED */\r\n    public static readonly GL_ALPHA_FUNCTION_SRC_ALPHA_SATURATED = 0x0308;\r\n    /** Alpha blend function: CONSTANT */\r\n    public static readonly GL_ALPHA_FUNCTION_CONSTANT_COLOR = 0x8001;\r\n    /** Alpha blend function: ONE_MINUS_CONSTANT */\r\n    public static readonly GL_ALPHA_FUNCTION_ONE_MINUS_CONSTANT_COLOR = 0x8002;\r\n    /** Alpha blend function: CONSTANT_ALPHA */\r\n    public static readonly GL_ALPHA_FUNCTION_CONSTANT_ALPHA = 0x8003;\r\n    /** Alpha blend function: ONE_MINUS_CONSTANT_ALPHA */\r\n    public static readonly GL_ALPHA_FUNCTION_ONE_MINUS_CONSTANT_ALPHA = 0x8004;\r\n    /** Alpha blend function: SRC1 */\r\n    public static readonly GL_ALPHA_FUNCTION_SRC1_COLOR = 0x88f9;\r\n    /** Alpha blend function: SRC1 */\r\n    public static readonly GL_ALPHA_FUNCTION_ONE_MINUS_SRC1_COLOR = 0x88fa;\r\n    /** Alpha blend function: SRC1 */\r\n    public static readonly GL_ALPHA_FUNCTION_SRC1_ALPHA = 0x8589;\r\n    /** Alpha blend function: SRC1 */\r\n    public static readonly GL_ALPHA_FUNCTION_ONE_MINUS_SRC1_ALPHA = 0x88fb;\r\n\r\n    /** URL to the snippet server. Points to the public snippet server by default */\r\n    public static SnippetUrl = \"https://snippet.babylonjs.com\";\r\n\r\n    /** The fog is deactivated */\r\n    public static FOGMODE_NONE = 0;\r\n    /** The fog density is following an exponential function */\r\n    public static FOGMODE_EXP = 1;\r\n    /** The fog density is following an exponential function faster than FOGMODE_EXP */\r\n    public static FOGMODE_EXP2 = 2;\r\n    /** The fog density is following a linear function. */\r\n    public static FOGMODE_LINEAR = 3;\r\n\r\n    /**\r\n     * The byte type.\r\n     */\r\n    public static BYTE = 5120;\r\n\r\n    /**\r\n     * The unsigned byte type.\r\n     */\r\n    public static UNSIGNED_BYTE = 5121;\r\n\r\n    /**\r\n     * The short type.\r\n     */\r\n    public static SHORT = 5122;\r\n\r\n    /**\r\n     * The unsigned short type.\r\n     */\r\n    public static UNSIGNED_SHORT = 5123;\r\n\r\n    /**\r\n     * The integer type.\r\n     */\r\n    public static INT = 5124;\r\n\r\n    /**\r\n     * The unsigned integer type.\r\n     */\r\n    public static UNSIGNED_INT = 5125;\r\n\r\n    /**\r\n     * The float type.\r\n     */\r\n    public static FLOAT = 5126;\r\n\r\n    /**\r\n     * Positions\r\n     */\r\n    public static PositionKind = \"position\";\r\n    /**\r\n     * Normals\r\n     */\r\n    public static NormalKind = \"normal\";\r\n    /**\r\n     * Tangents\r\n     */\r\n    public static TangentKind = \"tangent\";\r\n    /**\r\n     * Texture coordinates\r\n     */\r\n    public static UVKind = \"uv\";\r\n    /**\r\n     * Texture coordinates 2\r\n     */\r\n    public static UV2Kind = \"uv2\";\r\n    /**\r\n     * Texture coordinates 3\r\n     */\r\n    public static UV3Kind = \"uv3\";\r\n    /**\r\n     * Texture coordinates 4\r\n     */\r\n    public static UV4Kind = \"uv4\";\r\n    /**\r\n     * Texture coordinates 5\r\n     */\r\n    public static UV5Kind = \"uv5\";\r\n    /**\r\n     * Texture coordinates 6\r\n     */\r\n    public static UV6Kind = \"uv6\";\r\n    /**\r\n     * Colors\r\n     */\r\n    public static ColorKind = \"color\";\r\n    /**\r\n     * Instance Colors\r\n     */\r\n    public static ColorInstanceKind = \"instanceColor\";\r\n    /**\r\n     * Matrix indices (for bones)\r\n     */\r\n    public static MatricesIndicesKind = \"matricesIndices\";\r\n    /**\r\n     * Matrix weights (for bones)\r\n     */\r\n    public static MatricesWeightsKind = \"matricesWeights\";\r\n    /**\r\n     * Additional matrix indices (for bones)\r\n     */\r\n    public static MatricesIndicesExtraKind = \"matricesIndicesExtra\";\r\n    /**\r\n     * Additional matrix weights (for bones)\r\n     */\r\n    public static MatricesWeightsExtraKind = \"matricesWeightsExtra\";\r\n\r\n    // Animation type\r\n    /**\r\n     * Float animation type\r\n     */\r\n    public static readonly ANIMATIONTYPE_FLOAT = 0;\r\n    /**\r\n     * Vector3 animation type\r\n     */\r\n    public static readonly ANIMATIONTYPE_VECTOR3 = 1;\r\n    /**\r\n     * Quaternion animation type\r\n     */\r\n    public static readonly ANIMATIONTYPE_QUATERNION = 2;\r\n    /**\r\n     * Matrix animation type\r\n     */\r\n    public static readonly ANIMATIONTYPE_MATRIX = 3;\r\n    /**\r\n     * Color3 animation type\r\n     */\r\n    public static readonly ANIMATIONTYPE_COLOR3 = 4;\r\n    /**\r\n     * Color3 animation type\r\n     */\r\n    public static readonly ANIMATIONTYPE_COLOR4 = 7;\r\n    /**\r\n     * Vector2 animation type\r\n     */\r\n    public static readonly ANIMATIONTYPE_VECTOR2 = 5;\r\n    /**\r\n     * Size animation type\r\n     */\r\n    public static readonly ANIMATIONTYPE_SIZE = 6;\r\n\r\n    /**\r\n     * The default minZ value for the near plane of a frustum light\r\n     */\r\n    public static ShadowMinZ = 0;\r\n    /**\r\n     * The default maxZ value for the far plane of a frustum light\r\n     */\r\n    public static ShadowMaxZ = 10000;\r\n}\r\n", "import { serialize, serializeAsVector3 } from \"../Misc/decorators\";\r\nimport type { Camera } from \"../Cameras/camera\";\r\nimport type { Scene } from \"../scene\";\r\nimport { Matrix, TmpVectors, Vector3 } from \"../Maths/math.vector\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { Light } from \"./light\";\r\nimport { Axis } from \"../Maths/math.axis\";\r\nimport type { Nullable } from \"core/types\";\r\nimport { Constants } from \"core/Engines/constants\";\r\n/**\r\n * Interface describing all the common properties and methods a shadow light needs to implement.\r\n * This helps both the shadow generator and materials to generate the corresponding shadow maps\r\n * as well as binding the different shadow properties to the effects.\r\n */\r\nexport interface IShadowLight extends Light {\r\n    /**\r\n     * The light id in the scene (used in scene.getLightById for instance)\r\n     */\r\n    id: string;\r\n    /**\r\n     * The position the shadow will be casted from.\r\n     */\r\n    position: Vector3;\r\n    /**\r\n     * In 2d mode (needCube being false), the direction used to cast the shadow.\r\n     */\r\n    direction: Vector3;\r\n    /**\r\n     * The transformed position. Position of the light in world space taking parenting in account.\r\n     */\r\n    transformedPosition: Vector3;\r\n    /**\r\n     * The transformed direction. Direction of the light in world space taking parenting in account.\r\n     */\r\n    transformedDirection: Vector3;\r\n    /**\r\n     * The friendly name of the light in the scene.\r\n     */\r\n    name: string;\r\n    /**\r\n     * Defines the shadow projection clipping minimum z value.\r\n     */\r\n    shadowMinZ: number;\r\n    /**\r\n     * Defines the shadow projection clipping maximum z value.\r\n     */\r\n    shadowMaxZ: number;\r\n\r\n    /**\r\n     * Computes the transformed information (transformedPosition and transformedDirection in World space) of the current light\r\n     * @returns true if the information has been computed, false if it does not need to (no parenting)\r\n     */\r\n    computeTransformedInformation(): boolean;\r\n\r\n    /**\r\n     * Gets the scene the light belongs to.\r\n     * @returns The scene\r\n     */\r\n    getScene(): Scene;\r\n\r\n    /**\r\n     * Callback defining a custom Projection Matrix Builder.\r\n     * This can be used to override the default projection matrix computation.\r\n     */\r\n    customProjectionMatrixBuilder: (viewMatrix: Matrix, renderList: Array<AbstractMesh>, result: Matrix) => void;\r\n\r\n    /**\r\n     * Sets the shadow projection matrix in parameter to the generated projection matrix.\r\n     * @param matrix The matrix to update with the projection information\r\n     * @param viewMatrix The transform matrix of the light\r\n     * @param renderList The list of mesh to render in the map\r\n     * @returns The current light\r\n     */\r\n    setShadowProjectionMatrix(matrix: Matrix, viewMatrix: Matrix, renderList: Array<AbstractMesh>): IShadowLight;\r\n\r\n    /**\r\n     * Gets the current depth scale used in ESM.\r\n     * @returns The scale\r\n     */\r\n    getDepthScale(): number;\r\n\r\n    /**\r\n     * Returns whether or not the shadow generation require a cube texture or a 2d texture.\r\n     * @returns true if a cube texture needs to be use\r\n     */\r\n    needCube(): boolean;\r\n\r\n    /**\r\n     * Detects if the projection matrix requires to be recomputed this frame.\r\n     * @returns true if it requires to be recomputed otherwise, false.\r\n     */\r\n    needProjectionMatrixCompute(): boolean;\r\n\r\n    /**\r\n     * Forces the shadow generator to recompute the projection matrix even if position and direction did not changed.\r\n     */\r\n    forceProjectionMatrixCompute(): void;\r\n\r\n    /**\r\n     * Get the direction to use to render the shadow map. In case of cube texture, the face index can be passed.\r\n     * @param faceIndex The index of the face we are computed the direction to generate shadow\r\n     * @returns The set direction in 2d mode otherwise the direction to the cubemap face if needCube() is true\r\n     */\r\n    getShadowDirection(faceIndex?: number): Vector3;\r\n\r\n    /**\r\n     * Gets the minZ used for shadow according to both the scene and the light.\r\n     * @param activeCamera The camera we are returning the min for\r\n     * @returns the depth min z\r\n     */\r\n    getDepthMinZ(activeCamera: Nullable<Camera>): number;\r\n\r\n    /**\r\n     * Gets the maxZ used for shadow according to both the scene and the light.\r\n     * @param activeCamera The camera we are returning the max for\r\n     * @returns the depth max z\r\n     */\r\n    getDepthMaxZ(activeCamera: Nullable<Camera>): number;\r\n}\r\n\r\n/**\r\n * Base implementation IShadowLight\r\n * It groups all the common behaviour in order to reduce duplication and better follow the DRY pattern.\r\n */\r\nexport abstract class ShadowLight extends Light implements IShadowLight {\r\n    protected abstract _setDefaultShadowProjectionMatrix(matrix: Matrix, viewMatrix: Matrix, renderList: Array<AbstractMesh>): void;\r\n\r\n    protected _position: Vector3;\r\n    protected _setPosition(value: Vector3) {\r\n        this._position = value;\r\n    }\r\n    /**\r\n     * Sets the position the shadow will be casted from. Also use as the light position for both\r\n     * point and spot lights.\r\n     */\r\n    @serializeAsVector3()\r\n    public get position(): Vector3 {\r\n        return this._position;\r\n    }\r\n    /**\r\n     * Sets the position the shadow will be casted from. Also use as the light position for both\r\n     * point and spot lights.\r\n     */\r\n    public set position(value: Vector3) {\r\n        this._setPosition(value);\r\n    }\r\n\r\n    protected _direction: Vector3;\r\n    protected _setDirection(value: Vector3) {\r\n        this._direction = value;\r\n    }\r\n    /**\r\n     * In 2d mode (needCube being false), gets the direction used to cast the shadow.\r\n     * Also use as the light direction on spot and directional lights.\r\n     */\r\n    @serializeAsVector3()\r\n    public get direction(): Vector3 {\r\n        return this._direction;\r\n    }\r\n    /**\r\n     * In 2d mode (needCube being false), sets the direction used to cast the shadow.\r\n     * Also use as the light direction on spot and directional lights.\r\n     */\r\n    public set direction(value: Vector3) {\r\n        this._setDirection(value);\r\n    }\r\n\r\n    protected _shadowMinZ: number;\r\n    /**\r\n     * Gets the shadow projection clipping minimum z value.\r\n     */\r\n    @serialize()\r\n    public get shadowMinZ(): number {\r\n        return this._shadowMinZ;\r\n    }\r\n    /**\r\n     * Sets the shadow projection clipping minimum z value.\r\n     */\r\n    public set shadowMinZ(value: number) {\r\n        this._shadowMinZ = value;\r\n        this.forceProjectionMatrixCompute();\r\n    }\r\n\r\n    protected _shadowMaxZ: number;\r\n    /**\r\n     * Sets the shadow projection clipping maximum z value.\r\n     */\r\n    @serialize()\r\n    public get shadowMaxZ(): number {\r\n        return this._shadowMaxZ;\r\n    }\r\n    /**\r\n     * Gets the shadow projection clipping maximum z value.\r\n     */\r\n    public set shadowMaxZ(value: number) {\r\n        this._shadowMaxZ = value;\r\n        this.forceProjectionMatrixCompute();\r\n    }\r\n\r\n    /**\r\n     * Callback defining a custom Projection Matrix Builder.\r\n     * This can be used to override the default projection matrix computation.\r\n     */\r\n    public customProjectionMatrixBuilder: (viewMatrix: Matrix, renderList: Array<AbstractMesh>, result: Matrix) => void;\r\n\r\n    /**\r\n     * The transformed position. Position of the light in world space taking parenting in account. Needs to be computed by calling computeTransformedInformation.\r\n     */\r\n    public transformedPosition: Vector3;\r\n\r\n    /**\r\n     * The transformed direction. Direction of the light in world space taking parenting in account.\r\n     */\r\n    public transformedDirection: Vector3;\r\n\r\n    private _needProjectionMatrixCompute: boolean = true;\r\n\r\n    /**\r\n     * Computes the transformed information (transformedPosition and transformedDirection in World space) of the current light\r\n     * @returns true if the information has been computed, false if it does not need to (no parenting)\r\n     */\r\n    public computeTransformedInformation(): boolean {\r\n        if (this.parent && this.parent.getWorldMatrix) {\r\n            if (!this.transformedPosition) {\r\n                this.transformedPosition = Vector3.Zero();\r\n            }\r\n            Vector3.TransformCoordinatesToRef(this.position, this.parent.getWorldMatrix(), this.transformedPosition);\r\n\r\n            // In case the direction is present.\r\n            if (this.direction) {\r\n                if (!this.transformedDirection) {\r\n                    this.transformedDirection = Vector3.Zero();\r\n                }\r\n                Vector3.TransformNormalToRef(this.direction, this.parent.getWorldMatrix(), this.transformedDirection);\r\n            }\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Return the depth scale used for the shadow map.\r\n     * @returns the depth scale.\r\n     */\r\n    public getDepthScale(): number {\r\n        return 50.0;\r\n    }\r\n\r\n    /**\r\n     * Get the direction to use to render the shadow map. In case of cube texture, the face index can be passed.\r\n     * @param faceIndex The index of the face we are computed the direction to generate shadow\r\n     * @returns The set direction in 2d mode otherwise the direction to the cubemap face if needCube() is true\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public getShadowDirection(faceIndex?: number): Vector3 {\r\n        return this.transformedDirection ? this.transformedDirection : this.direction;\r\n    }\r\n\r\n    /**\r\n     * If computeTransformedInformation has been called, returns the ShadowLight absolute position in the world. Otherwise, returns the local position.\r\n     * @returns the position vector in world space\r\n     */\r\n    public override getAbsolutePosition(): Vector3 {\r\n        return this.transformedPosition ? this.transformedPosition : this.position;\r\n    }\r\n\r\n    /**\r\n     * Sets the ShadowLight direction toward the passed target.\r\n     * @param target The point to target in local space\r\n     * @returns the updated ShadowLight direction\r\n     */\r\n    public setDirectionToTarget(target: Vector3): Vector3 {\r\n        this.direction = Vector3.Normalize(target.subtract(this.position));\r\n        return this.direction;\r\n    }\r\n\r\n    /**\r\n     * Returns the light rotation in euler definition.\r\n     * @returns the x y z rotation in local space.\r\n     */\r\n    public getRotation(): Vector3 {\r\n        this.direction.normalize();\r\n        const xaxis = Vector3.Cross(this.direction, Axis.Y);\r\n        const yaxis = Vector3.Cross(xaxis, this.direction);\r\n        return Vector3.RotationFromAxis(xaxis, yaxis, this.direction);\r\n    }\r\n\r\n    /**\r\n     * Returns whether or not the shadow generation require a cube texture or a 2d texture.\r\n     * @returns true if a cube texture needs to be use\r\n     */\r\n    public needCube(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Detects if the projection matrix requires to be recomputed this frame.\r\n     * @returns true if it requires to be recomputed otherwise, false.\r\n     */\r\n    public needProjectionMatrixCompute(): boolean {\r\n        return this._needProjectionMatrixCompute;\r\n    }\r\n\r\n    /**\r\n     * Forces the shadow generator to recompute the projection matrix even if position and direction did not changed.\r\n     */\r\n    public forceProjectionMatrixCompute(): void {\r\n        this._needProjectionMatrixCompute = true;\r\n    }\r\n\r\n    /** @internal */\r\n    public override _initCache() {\r\n        super._initCache();\r\n\r\n        this._cache.position = Vector3.Zero();\r\n    }\r\n\r\n    /** @internal */\r\n    public override _isSynchronized(): boolean {\r\n        if (!this._cache.position.equals(this.position)) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Computes the world matrix of the node\r\n     * @param force defines if the cache version should be invalidated forcing the world matrix to be created from scratch\r\n     * @returns the world matrix\r\n     */\r\n    public override computeWorldMatrix(force?: boolean): Matrix {\r\n        if (!force && this.isSynchronized()) {\r\n            this._currentRenderId = this.getScene().getRenderId();\r\n            return this._worldMatrix;\r\n        }\r\n\r\n        this._updateCache();\r\n        this._cache.position.copyFrom(this.position);\r\n\r\n        if (!this._worldMatrix) {\r\n            this._worldMatrix = Matrix.Identity();\r\n        }\r\n\r\n        Matrix.TranslationToRef(this.position.x, this.position.y, this.position.z, this._worldMatrix);\r\n\r\n        if (this.parent && this.parent.getWorldMatrix) {\r\n            this._worldMatrix.multiplyToRef(this.parent.getWorldMatrix(), this._worldMatrix);\r\n\r\n            this._markSyncedWithParent();\r\n        }\r\n\r\n        // Cache the determinant\r\n        this._worldMatrixDeterminantIsDirty = true;\r\n\r\n        return this._worldMatrix;\r\n    }\r\n\r\n    /**\r\n     * Gets the minZ used for shadow according to both the scene and the light.\r\n     * @param activeCamera The camera we are returning the min for\r\n     * @returns the depth min z\r\n     */\r\n    public getDepthMinZ(activeCamera: Nullable<Camera>): number {\r\n        return this.shadowMinZ !== undefined ? this.shadowMinZ : activeCamera?.minZ || Constants.ShadowMinZ;\r\n    }\r\n\r\n    /**\r\n     * Gets the maxZ used for shadow according to both the scene and the light.\r\n     * @param activeCamera The camera we are returning the max for\r\n     * @returns the depth max z\r\n     */\r\n    public getDepthMaxZ(activeCamera: Nullable<Camera>): number {\r\n        return this.shadowMaxZ !== undefined ? this.shadowMaxZ : activeCamera?.maxZ || Constants.ShadowMaxZ;\r\n    }\r\n\r\n    /**\r\n     * Sets the shadow projection matrix in parameter to the generated projection matrix.\r\n     * @param matrix The matrix to updated with the projection information\r\n     * @param viewMatrix The transform matrix of the light\r\n     * @param renderList The list of mesh to render in the map\r\n     * @returns The current light\r\n     */\r\n    public setShadowProjectionMatrix(matrix: Matrix, viewMatrix: Matrix, renderList: Array<AbstractMesh>): IShadowLight {\r\n        if (this.customProjectionMatrixBuilder) {\r\n            this.customProjectionMatrixBuilder(viewMatrix, renderList, matrix);\r\n        } else {\r\n            this._setDefaultShadowProjectionMatrix(matrix, viewMatrix, renderList);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /** @internal */\r\n    protected override _syncParentEnabledState() {\r\n        super._syncParentEnabledState();\r\n        if (!this.parent || !this.parent.getWorldMatrix) {\r\n            (this.transformedPosition as any) = null;\r\n            (this.transformedDirection as any) = null;\r\n        }\r\n    }\r\n\r\n    protected _viewMatrix: Matrix = Matrix.Identity();\r\n    protected _projectionMatrix: Matrix = Matrix.Identity();\r\n\r\n    /**\r\n     * Returns the view matrix.\r\n     * @param faceIndex The index of the face for which we want to extract the view matrix. Only used for point light types.\r\n     * @returns The view matrix. Can be null, if a view matrix cannot be defined for the type of light considered (as for a hemispherical light, for example).\r\n     */\r\n    public override getViewMatrix(faceIndex?: number): Nullable<Matrix> {\r\n        const lightDirection = TmpVectors.Vector3[0];\r\n\r\n        let lightPosition = this.position;\r\n        if (this.computeTransformedInformation()) {\r\n            lightPosition = this.transformedPosition;\r\n        }\r\n\r\n        Vector3.NormalizeToRef(this.getShadowDirection(faceIndex), lightDirection);\r\n        if (Math.abs(Vector3.Dot(lightDirection, Vector3.Up())) === 1.0) {\r\n            lightDirection.z = 0.0000000000001; // Required to avoid perfectly perpendicular light\r\n        }\r\n\r\n        const lightTarget = TmpVectors.Vector3[1];\r\n        lightPosition.addToRef(lightDirection, lightTarget);\r\n\r\n        Matrix.LookAtLHToRef(lightPosition, lightTarget, Vector3.Up(), this._viewMatrix);\r\n\r\n        return this._viewMatrix;\r\n    }\r\n\r\n    /**\r\n     * Returns the projection matrix.\r\n     * Note that viewMatrix and renderList are optional and are only used by lights that calculate the projection matrix from a list of meshes (e.g. directional lights with automatic extents calculation).\r\n     * @param viewMatrix The view transform matrix of the light (optional).\r\n     * @param renderList The list of meshes to take into account when calculating the projection matrix (optional).\r\n     * @returns The projection matrix. Can be null, if a projection matrix cannot be defined for the type of light considered (as for a hemispherical light, for example).\r\n     */\r\n    public override getProjectionMatrix(viewMatrix?: Matrix, renderList?: Array<AbstractMesh>): Nullable<Matrix> {\r\n        this.setShadowProjectionMatrix(this._projectionMatrix, viewMatrix ?? this._viewMatrix, renderList ?? []);\r\n\r\n        return this._projectionMatrix;\r\n    }\r\n}\r\n", "import { serialize, serializeAsTexture } from \"../Misc/decorators\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { Scene } from \"../scene\";\r\nimport { Matrix, Vector3 } from \"../Maths/math.vector\";\r\nimport { Node } from \"../node\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport type { Effect } from \"../Materials/effect\";\r\nimport type { BaseTexture } from \"../Materials/Textures/baseTexture\";\r\nimport { Light } from \"./light\";\r\nimport { ShadowLight } from \"./shadowLight\";\r\nimport { Texture } from \"../Materials/Textures/texture\";\r\nimport type { ProceduralTexture } from \"../Materials/Textures/Procedurals/proceduralTexture\";\r\nimport type { Camera } from \"../Cameras/camera\";\r\nimport { RegisterClass } from \"../Misc/typeStore\";\r\nimport { Constants } from \"core/Engines/constants\";\r\n\r\nNode.AddNodeConstructor(\"Light_Type_2\", (name, scene) => {\r\n    return () => new SpotLight(name, Vector3.Zero(), Vector3.Zero(), 0, 0, scene);\r\n});\r\n\r\n/**\r\n * A spot light is defined by a position, a direction, an angle, and an exponent.\r\n * These values define a cone of light starting from the position, emitting toward the direction.\r\n * The angle, in radians, defines the size (field of illumination) of the spotlight's conical beam,\r\n * and the exponent defines the speed of the decay of the light with distance (reach).\r\n * Documentation: https://doc.babylonjs.com/features/featuresDeepDive/lights/lights_introduction\r\n */\r\nexport class SpotLight extends ShadowLight {\r\n    /*\r\n        upVector , rightVector and direction will form the coordinate system for this spot light.\r\n        These three vectors will be used as projection matrix when doing texture projection.\r\n\r\n        Also we have the following rules always holds:\r\n        direction cross up   = right\r\n        right cross direction = up\r\n        up cross right       = forward\r\n\r\n        light_near and light_far will control the range of the texture projection. If a plane is\r\n        out of the range in spot light space, there is no texture projection.\r\n    */\r\n\r\n    private _angle: number;\r\n    private _innerAngle: number = 0;\r\n    private _cosHalfAngle: number;\r\n\r\n    private _lightAngleScale: number;\r\n    private _lightAngleOffset: number;\r\n\r\n    private _iesProfileTexture: Nullable<BaseTexture> = null;\r\n\r\n    /**\r\n     * Gets or sets the IES profile texture used to create the spotlight\r\n     * #UIAXAU#1\r\n     */\r\n    public get iesProfileTexture(): Nullable<BaseTexture> {\r\n        return this._iesProfileTexture;\r\n    }\r\n\r\n    public set iesProfileTexture(value: Nullable<BaseTexture>) {\r\n        if (this._iesProfileTexture === value) {\r\n            return;\r\n        }\r\n\r\n        this._iesProfileTexture = value;\r\n\r\n        if (this._iesProfileTexture && SpotLight._IsTexture(this._iesProfileTexture)) {\r\n            this._iesProfileTexture.onLoadObservable.addOnce(() => {\r\n                this._markMeshesAsLightDirty();\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the cone angle of the spot light in Radians.\r\n     */\r\n    @serialize()\r\n    public get angle(): number {\r\n        return this._angle;\r\n    }\r\n    /**\r\n     * Sets the cone angle of the spot light in Radians.\r\n     */\r\n    public set angle(value: number) {\r\n        this._angle = value;\r\n        this._cosHalfAngle = Math.cos(value * 0.5);\r\n        this._projectionTextureProjectionLightDirty = true;\r\n        this.forceProjectionMatrixCompute();\r\n        this._computeAngleValues();\r\n    }\r\n\r\n    /**\r\n     * Only used in gltf falloff mode, this defines the angle where\r\n     * the directional falloff will start before cutting at angle which could be seen\r\n     * as outer angle.\r\n     */\r\n    @serialize()\r\n    public get innerAngle(): number {\r\n        return this._innerAngle;\r\n    }\r\n    /**\r\n     * Only used in gltf falloff mode, this defines the angle where\r\n     * the directional falloff will start before cutting at angle which could be seen\r\n     * as outer angle.\r\n     */\r\n    public set innerAngle(value: number) {\r\n        this._innerAngle = value;\r\n        this._computeAngleValues();\r\n    }\r\n\r\n    private _shadowAngleScale: number;\r\n    /**\r\n     * Allows scaling the angle of the light for shadow generation only.\r\n     */\r\n    @serialize()\r\n    public get shadowAngleScale(): number {\r\n        return this._shadowAngleScale;\r\n    }\r\n    /**\r\n     * Allows scaling the angle of the light for shadow generation only.\r\n     */\r\n    public set shadowAngleScale(value: number) {\r\n        this._shadowAngleScale = value;\r\n        this.forceProjectionMatrixCompute();\r\n    }\r\n\r\n    /**\r\n     * The light decay speed with the distance from the emission spot.\r\n     */\r\n    @serialize()\r\n    public exponent: number;\r\n\r\n    private _projectionTextureMatrix = Matrix.Zero();\r\n    /**\r\n     * Allows reading the projection texture\r\n     */\r\n    public get projectionTextureMatrix(): Matrix {\r\n        return this._projectionTextureMatrix;\r\n    }\r\n\r\n    protected _projectionTextureLightNear: number = 1e-6;\r\n    /**\r\n     * Gets the near clip of the Spotlight for texture projection.\r\n     */\r\n    @serialize()\r\n    public get projectionTextureLightNear(): number {\r\n        return this._projectionTextureLightNear;\r\n    }\r\n    /**\r\n     * Sets the near clip of the Spotlight for texture projection.\r\n     */\r\n    public set projectionTextureLightNear(value: number) {\r\n        this._projectionTextureLightNear = value;\r\n        this._projectionTextureProjectionLightDirty = true;\r\n    }\r\n\r\n    protected _projectionTextureLightFar: number = 1000.0;\r\n    /**\r\n     * Gets the far clip of the Spotlight for texture projection.\r\n     */\r\n    @serialize()\r\n    public get projectionTextureLightFar(): number {\r\n        return this._projectionTextureLightFar;\r\n    }\r\n    /**\r\n     * Sets the far clip of the Spotlight for texture projection.\r\n     */\r\n    public set projectionTextureLightFar(value: number) {\r\n        this._projectionTextureLightFar = value;\r\n        this._projectionTextureProjectionLightDirty = true;\r\n    }\r\n\r\n    protected _projectionTextureUpDirection: Vector3 = Vector3.Up();\r\n    /**\r\n     * Gets the Up vector of the Spotlight for texture projection.\r\n     */\r\n    @serialize()\r\n    public get projectionTextureUpDirection(): Vector3 {\r\n        return this._projectionTextureUpDirection;\r\n    }\r\n    /**\r\n     * Sets the Up vector of the Spotlight for texture projection.\r\n     */\r\n    public set projectionTextureUpDirection(value: Vector3) {\r\n        this._projectionTextureUpDirection = value;\r\n        this._projectionTextureProjectionLightDirty = true;\r\n    }\r\n\r\n    @serializeAsTexture(\"projectedLightTexture\")\r\n    private _projectionTexture: Nullable<BaseTexture>;\r\n\r\n    /**\r\n     * Gets the projection texture of the light.\r\n     */\r\n    public get projectionTexture(): Nullable<BaseTexture> {\r\n        return this._projectionTexture;\r\n    }\r\n    /**\r\n     * Sets the projection texture of the light.\r\n     */\r\n    public set projectionTexture(value: Nullable<BaseTexture>) {\r\n        if (this._projectionTexture === value) {\r\n            return;\r\n        }\r\n        this._projectionTexture = value;\r\n        this._projectionTextureDirty = true;\r\n        if (this._projectionTexture && !this._projectionTexture.isReady()) {\r\n            if (SpotLight._IsProceduralTexture(this._projectionTexture)) {\r\n                this._projectionTexture.getEffect().executeWhenCompiled(() => {\r\n                    this._markMeshesAsLightDirty();\r\n                });\r\n            } else if (SpotLight._IsTexture(this._projectionTexture)) {\r\n                this._projectionTexture.onLoadObservable.addOnce(() => {\r\n                    this._markMeshesAsLightDirty();\r\n                });\r\n            }\r\n        }\r\n    }\r\n\r\n    private static _IsProceduralTexture(texture: BaseTexture): texture is ProceduralTexture {\r\n        return (texture as ProceduralTexture).onGeneratedObservable !== undefined;\r\n    }\r\n\r\n    private static _IsTexture(texture: BaseTexture): texture is Texture {\r\n        return (texture as Texture).onLoadObservable !== undefined;\r\n    }\r\n\r\n    private _projectionTextureViewLightDirty = true;\r\n    private _projectionTextureProjectionLightDirty = true;\r\n    private _projectionTextureDirty = true;\r\n    private _projectionTextureViewTargetVector = Vector3.Zero();\r\n    private _projectionTextureViewLightMatrix = Matrix.Zero();\r\n\r\n    private _projectionTextureProjectionLightMatrix = Matrix.Zero();\r\n    /**\r\n     * Gets or sets the light projection matrix as used by the projection texture\r\n     */\r\n    public get projectionTextureProjectionLightMatrix(): Matrix {\r\n        return this._projectionTextureProjectionLightMatrix;\r\n    }\r\n\r\n    public set projectionTextureProjectionLightMatrix(projection: Matrix) {\r\n        this._projectionTextureProjectionLightMatrix = projection;\r\n        this._projectionTextureProjectionLightDirty = false;\r\n        this._projectionTextureDirty = true;\r\n    }\r\n\r\n    private _projectionTextureScalingMatrix = Matrix.FromValues(0.5, 0.0, 0.0, 0.0, 0.0, 0.5, 0.0, 0.0, 0.0, 0.0, 0.5, 0.0, 0.5, 0.5, 0.5, 1.0);\r\n\r\n    /**\r\n     * Creates a SpotLight object in the scene. A spot light is a simply light oriented cone.\r\n     * It can cast shadows.\r\n     * Documentation : https://doc.babylonjs.com/features/featuresDeepDive/lights/lights_introduction\r\n     * @param name The light friendly name\r\n     * @param position The position of the spot light in the scene\r\n     * @param direction The direction of the light in the scene\r\n     * @param angle The cone angle of the light in Radians\r\n     * @param exponent The light decay speed with the distance from the emission spot\r\n     * @param scene The scene the lights belongs to\r\n     */\r\n    constructor(name: string, position: Vector3, direction: Vector3, angle: number, exponent: number, scene?: Scene) {\r\n        super(name, scene);\r\n\r\n        this.position = position;\r\n        this.direction = direction;\r\n        this.angle = angle;\r\n        this.exponent = exponent;\r\n    }\r\n\r\n    /**\r\n     * Returns the string \"SpotLight\".\r\n     * @returns the class name\r\n     */\r\n    public override getClassName(): string {\r\n        return \"SpotLight\";\r\n    }\r\n\r\n    /**\r\n     * Returns the integer 2.\r\n     * @returns The light Type id as a constant defines in Light.LIGHTTYPEID_x\r\n     */\r\n    public override getTypeID(): number {\r\n        return Light.LIGHTTYPEID_SPOTLIGHT;\r\n    }\r\n\r\n    /**\r\n     * Overrides the direction setter to recompute the projection texture view light Matrix.\r\n     * @param value\r\n     */\r\n    protected override _setDirection(value: Vector3) {\r\n        super._setDirection(value);\r\n        this._projectionTextureViewLightDirty = true;\r\n    }\r\n\r\n    /**\r\n     * Overrides the position setter to recompute the projection texture view light Matrix.\r\n     * @param value\r\n     */\r\n    protected override _setPosition(value: Vector3) {\r\n        super._setPosition(value);\r\n        this._projectionTextureViewLightDirty = true;\r\n    }\r\n\r\n    /**\r\n     * Sets the passed matrix \"matrix\" as perspective projection matrix for the shadows and the passed view matrix with the fov equal to the SpotLight angle and and aspect ratio of 1.0.\r\n     * Returns the SpotLight.\r\n     * @param matrix\r\n     * @param viewMatrix\r\n     * @param renderList\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    protected _setDefaultShadowProjectionMatrix(matrix: Matrix, viewMatrix: Matrix, renderList: Array<AbstractMesh>): void {\r\n        const activeCamera = this.getScene().activeCamera;\r\n\r\n        if (!activeCamera) {\r\n            return;\r\n        }\r\n\r\n        this._shadowAngleScale = this._shadowAngleScale || 1;\r\n        const angle = this._shadowAngleScale * this._angle;\r\n\r\n        const minZ = this.shadowMinZ !== undefined ? this.shadowMinZ : activeCamera.minZ;\r\n        const maxZ = this.shadowMaxZ !== undefined ? this.shadowMaxZ : activeCamera.maxZ;\r\n\r\n        const useReverseDepthBuffer = this.getScene().getEngine().useReverseDepthBuffer;\r\n\r\n        Matrix.PerspectiveFovLHToRef(\r\n            angle,\r\n            1.0,\r\n            useReverseDepthBuffer ? maxZ : minZ,\r\n            useReverseDepthBuffer ? minZ : maxZ,\r\n            matrix,\r\n            true,\r\n            this._scene.getEngine().isNDCHalfZRange,\r\n            undefined,\r\n            useReverseDepthBuffer\r\n        );\r\n    }\r\n\r\n    protected _computeProjectionTextureViewLightMatrix(): void {\r\n        this._projectionTextureViewLightDirty = false;\r\n        this._projectionTextureDirty = true;\r\n\r\n        this.getAbsolutePosition().addToRef(this.getShadowDirection(), this._projectionTextureViewTargetVector);\r\n        Matrix.LookAtLHToRef(this.getAbsolutePosition(), this._projectionTextureViewTargetVector, this._projectionTextureUpDirection, this._projectionTextureViewLightMatrix);\r\n    }\r\n\r\n    protected _computeProjectionTextureProjectionLightMatrix(): void {\r\n        this._projectionTextureProjectionLightDirty = false;\r\n        this._projectionTextureDirty = true;\r\n\r\n        const lightFar = this.projectionTextureLightFar;\r\n        const lightNear = this.projectionTextureLightNear;\r\n\r\n        const P = lightFar / (lightFar - lightNear);\r\n        const Q = -P * lightNear;\r\n        const S = 1.0 / Math.tan(this._angle / 2.0);\r\n        const A = 1.0;\r\n\r\n        Matrix.FromValuesToRef(S / A, 0.0, 0.0, 0.0, 0.0, S, 0.0, 0.0, 0.0, 0.0, P, 1.0, 0.0, 0.0, Q, 0.0, this._projectionTextureProjectionLightMatrix);\r\n    }\r\n\r\n    /**\r\n     * Main function for light texture projection matrix computing.\r\n     */\r\n    protected _computeProjectionTextureMatrix(): void {\r\n        this._projectionTextureDirty = false;\r\n\r\n        this._projectionTextureViewLightMatrix.multiplyToRef(this._projectionTextureProjectionLightMatrix, this._projectionTextureMatrix);\r\n        if (this._projectionTexture instanceof Texture) {\r\n            const u = this._projectionTexture.uScale / 2.0;\r\n            const v = this._projectionTexture.vScale / 2.0;\r\n            Matrix.FromValuesToRef(u, 0.0, 0.0, 0.0, 0.0, v, 0.0, 0.0, 0.0, 0.0, 0.5, 0.0, 0.5, 0.5, 0.5, 1.0, this._projectionTextureScalingMatrix);\r\n        }\r\n        this._projectionTextureMatrix.multiplyToRef(this._projectionTextureScalingMatrix, this._projectionTextureMatrix);\r\n    }\r\n\r\n    protected _buildUniformLayout(): void {\r\n        this._uniformBuffer.addUniform(\"vLightData\", 4);\r\n        this._uniformBuffer.addUniform(\"vLightDiffuse\", 4);\r\n        this._uniformBuffer.addUniform(\"vLightSpecular\", 4);\r\n        this._uniformBuffer.addUniform(\"vLightDirection\", 3);\r\n        this._uniformBuffer.addUniform(\"vLightFalloff\", 4);\r\n        this._uniformBuffer.addUniform(\"shadowsInfo\", 3);\r\n        this._uniformBuffer.addUniform(\"depthValues\", 2);\r\n        this._uniformBuffer.create();\r\n    }\r\n\r\n    private _computeAngleValues(): void {\r\n        this._lightAngleScale = 1.0 / Math.max(0.001, Math.cos(this._innerAngle * 0.5) - this._cosHalfAngle);\r\n        this._lightAngleOffset = -this._cosHalfAngle * this._lightAngleScale;\r\n    }\r\n\r\n    /**\r\n     * Sets the passed Effect \"effect\" with the Light textures.\r\n     * @param effect The effect to update\r\n     * @param lightIndex The index of the light in the effect to update\r\n     * @returns The light\r\n     */\r\n    public override transferTexturesToEffect(effect: Effect, lightIndex: string): Light {\r\n        if (this.projectionTexture && this.projectionTexture.isReady()) {\r\n            if (this._projectionTextureViewLightDirty) {\r\n                this._computeProjectionTextureViewLightMatrix();\r\n            }\r\n            if (this._projectionTextureProjectionLightDirty) {\r\n                this._computeProjectionTextureProjectionLightMatrix();\r\n            }\r\n            if (this._projectionTextureDirty) {\r\n                this._computeProjectionTextureMatrix();\r\n            }\r\n            effect.setMatrix(\"textureProjectionMatrix\" + lightIndex, this._projectionTextureMatrix);\r\n            effect.setTexture(\"projectionLightTexture\" + lightIndex, this.projectionTexture);\r\n        }\r\n\r\n        if (this._iesProfileTexture && this._iesProfileTexture.isReady()) {\r\n            effect.setTexture(\"iesLightTexture\" + lightIndex, this._iesProfileTexture);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets the passed Effect object with the SpotLight transformed position (or position if not parented) and normalized direction.\r\n     * @param effect The effect to update\r\n     * @param lightIndex The index of the light in the effect to update\r\n     * @returns The spot light\r\n     */\r\n    public transferToEffect(effect: Effect, lightIndex: string): SpotLight {\r\n        let normalizeDirection;\r\n\r\n        if (this.computeTransformedInformation()) {\r\n            this._uniformBuffer.updateFloat4(\"vLightData\", this.transformedPosition.x, this.transformedPosition.y, this.transformedPosition.z, this.exponent, lightIndex);\r\n\r\n            normalizeDirection = Vector3.Normalize(this.transformedDirection);\r\n        } else {\r\n            this._uniformBuffer.updateFloat4(\"vLightData\", this.position.x, this.position.y, this.position.z, this.exponent, lightIndex);\r\n\r\n            normalizeDirection = Vector3.Normalize(this.direction);\r\n        }\r\n\r\n        this._uniformBuffer.updateFloat4(\"vLightDirection\", normalizeDirection.x, normalizeDirection.y, normalizeDirection.z, this._cosHalfAngle, lightIndex);\r\n\r\n        this._uniformBuffer.updateFloat4(\"vLightFalloff\", this.range, this._inverseSquaredRange, this._lightAngleScale, this._lightAngleOffset, lightIndex);\r\n        return this;\r\n    }\r\n\r\n    public transferToNodeMaterialEffect(effect: Effect, lightDataUniformName: string) {\r\n        let normalizeDirection;\r\n\r\n        if (this.computeTransformedInformation()) {\r\n            normalizeDirection = Vector3.Normalize(this.transformedDirection);\r\n        } else {\r\n            normalizeDirection = Vector3.Normalize(this.direction);\r\n        }\r\n\r\n        if (this.getScene().useRightHandedSystem) {\r\n            effect.setFloat3(lightDataUniformName, -normalizeDirection.x, -normalizeDirection.y, -normalizeDirection.z);\r\n        } else {\r\n            effect.setFloat3(lightDataUniformName, normalizeDirection.x, normalizeDirection.y, normalizeDirection.z);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Disposes the light and the associated resources.\r\n     */\r\n    public override dispose(): void {\r\n        super.dispose();\r\n        if (this._projectionTexture) {\r\n            this._projectionTexture.dispose();\r\n        }\r\n        if (this._iesProfileTexture) {\r\n            this._iesProfileTexture.dispose();\r\n            this._iesProfileTexture = null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the minZ used for shadow according to both the scene and the light.\r\n     * @param activeCamera The camera we are returning the min for\r\n     * @returns the depth min z\r\n     */\r\n    public override getDepthMinZ(activeCamera: Nullable<Camera>): number {\r\n        const engine = this._scene.getEngine();\r\n        const minZ = this.shadowMinZ !== undefined ? this.shadowMinZ : (activeCamera?.minZ ?? Constants.ShadowMinZ);\r\n\r\n        return engine.useReverseDepthBuffer && engine.isNDCHalfZRange ? minZ : this._scene.getEngine().isNDCHalfZRange ? 0 : minZ;\r\n    }\r\n\r\n    /**\r\n     * Gets the maxZ used for shadow according to both the scene and the light.\r\n     * @param activeCamera The camera we are returning the max for\r\n     * @returns the depth max z\r\n     */\r\n    public override getDepthMaxZ(activeCamera: Nullable<Camera>): number {\r\n        const engine = this._scene.getEngine();\r\n        const maxZ = this.shadowMaxZ !== undefined ? this.shadowMaxZ : (activeCamera?.maxZ ?? Constants.ShadowMaxZ);\r\n\r\n        return engine.useReverseDepthBuffer && engine.isNDCHalfZRange ? 0 : maxZ;\r\n    }\r\n\r\n    /**\r\n     * Prepares the list of defines specific to the light type.\r\n     * @param defines the list of defines\r\n     * @param lightIndex defines the index of the light for the effect\r\n     */\r\n    public prepareLightSpecificDefines(defines: any, lightIndex: number): void {\r\n        defines[\"SPOTLIGHT\" + lightIndex] = true;\r\n        defines[\"PROJECTEDLIGHTTEXTURE\" + lightIndex] = this.projectionTexture && this.projectionTexture.isReady() ? true : false;\r\n        defines[\"IESLIGHTTEXTURE\" + lightIndex] = this._iesProfileTexture && this._iesProfileTexture.isReady() ? true : false;\r\n    }\r\n}\r\n\r\n// Register Class Name\r\nRegisterClass(\"BABYLON.SpotLight\", SpotLight);\r\n"],
  "mappings": "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",
  "names": []
}
