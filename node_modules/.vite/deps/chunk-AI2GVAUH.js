import {
  Scene,
  init_scene
} from "./chunk-FXHL5NC5.js";
import {
  Tools,
  init_tools
} from "./chunk-EIDIARUE.js";
import {
  AbstractEngine,
  init_abstractEngine
} from "./chunk-4W4ABCPR.js";
import {
  EngineStore,
  init_engineStore
} from "./chunk-66MKRQMC.js";
import {
  Observable,
  init_observable
} from "./chunk-H6EIW4LR.js";
import {
  __esm
} from "./chunk-DZZM6G22.js";

// node_modules/@babylonjs/core/Debug/debugLayer.js
var DebugLayerTab, DebugLayer;
var init_debugLayer = __esm({
  "node_modules/@babylonjs/core/Debug/debugLayer.js"() {
    init_tools();
    init_observable();
    init_scene();
    init_engineStore();
    init_abstractEngine();
    Object.defineProperty(Scene.prototype, "debugLayer", {
      get: function() {
        if (!this._debugLayer) {
          this._debugLayer = new DebugLayer(this);
        }
        return this._debugLayer;
      },
      enumerable: true,
      configurable: true
    });
    (function(DebugLayerTab2) {
      DebugLayerTab2[DebugLayerTab2["Properties"] = 0] = "Properties";
      DebugLayerTab2[DebugLayerTab2["Debug"] = 1] = "Debug";
      DebugLayerTab2[DebugLayerTab2["Statistics"] = 2] = "Statistics";
      DebugLayerTab2[DebugLayerTab2["Tools"] = 3] = "Tools";
      DebugLayerTab2[DebugLayerTab2["Settings"] = 4] = "Settings";
    })(DebugLayerTab || (DebugLayerTab = {}));
    DebugLayer = class _DebugLayer {
      /**
       * Observable triggered when a property is changed through the inspector.
       */
      get onPropertyChangedObservable() {
        if (this.BJSINSPECTOR && this.BJSINSPECTOR.Inspector) {
          return this.BJSINSPECTOR.Inspector.OnPropertyChangedObservable;
        }
        if (!this._onPropertyChangedObservable) {
          this._onPropertyChangedObservable = new Observable();
        }
        return this._onPropertyChangedObservable;
      }
      /**
       * Observable triggered when the selection is changed through the inspector.
       */
      get onSelectionChangedObservable() {
        if (this.BJSINSPECTOR && this.BJSINSPECTOR.Inspector) {
          return this.BJSINSPECTOR.Inspector.OnSelectionChangeObservable;
        }
        if (!this._onSelectionChangedObservable) {
          this._onSelectionChangedObservable = new Observable();
        }
        return this._onSelectionChangedObservable;
      }
      /**
       * Instantiates a new debug layer.
       * The debug layer (aka Inspector) is the go to tool in order to better understand
       * what is happening in your scene
       * @see https://doc.babylonjs.com/toolsAndResources/inspector
       * @param scene Defines the scene to inspect
       */
      constructor(scene) {
        this.BJSINSPECTOR = this._getGlobalInspector();
        this._scene = scene || EngineStore.LastCreatedScene;
        if (!this._scene) {
          return;
        }
        this._scene.onDisposeObservable.add(() => {
          if (this._scene._debugLayer) {
            this._scene._debugLayer.hide();
          }
        });
      }
      /**
       * Creates the inspector window.
       * @param config
       */
      _createInspector(config) {
        if (this.isVisible()) {
          return;
        }
        if (this._onPropertyChangedObservable) {
          for (const observer of this._onPropertyChangedObservable.observers) {
            this.BJSINSPECTOR.Inspector.OnPropertyChangedObservable.add(observer);
          }
          this._onPropertyChangedObservable.clear();
          this._onPropertyChangedObservable = void 0;
        }
        if (this._onSelectionChangedObservable) {
          for (const observer of this._onSelectionChangedObservable.observers) {
            this.BJSINSPECTOR.Inspector.OnSelectionChangedObservable.add(observer);
          }
          this._onSelectionChangedObservable.clear();
          this._onSelectionChangedObservable = void 0;
        }
        const userOptions = {
          ..._DebugLayer.Config,
          ...config
        };
        this.BJSINSPECTOR = this.BJSINSPECTOR || this._getGlobalInspector();
        this.BJSINSPECTOR.Inspector.Show(this._scene, userOptions);
      }
      /**
       * Select a specific entity in the scene explorer and highlight a specific block in that entity property grid
       * @param entity defines the entity to select
       * @param lineContainerTitles defines the specific blocks to highlight (could be a string or an array of strings)
       */
      select(entity, lineContainerTitles) {
        if (this.BJSINSPECTOR) {
          if (lineContainerTitles) {
            if (Object.prototype.toString.call(lineContainerTitles) == "[object String]") {
              this.BJSINSPECTOR.Inspector.MarkLineContainerTitleForHighlighting(lineContainerTitles);
            } else {
              this.BJSINSPECTOR.Inspector.MarkMultipleLineContainerTitlesForHighlighting(lineContainerTitles);
            }
          }
          this.BJSINSPECTOR.Inspector.OnSelectionChangeObservable.notifyObservers(entity);
        }
      }
      /**
       * Get the inspector from bundle or global
       * @returns the inspector instance if found otherwise, null
       */
      _getGlobalInspector() {
        if (typeof INSPECTOR !== "undefined") {
          return INSPECTOR;
        }
        if (typeof BABYLON !== "undefined" && typeof BABYLON.Inspector !== "undefined") {
          return BABYLON;
        }
        return void 0;
      }
      /**
       * Get if the inspector is visible or not.
       * @returns true if visible otherwise, false
       */
      isVisible() {
        return this.BJSINSPECTOR && this.BJSINSPECTOR.Inspector.IsVisible;
      }
      /**
       * Hide the inspector and close its window.
       */
      hide() {
        if (this.BJSINSPECTOR) {
          this.BJSINSPECTOR.Inspector.Hide();
        }
      }
      /**
       * Get the number of opened panes in the inspector
       */
      get openedPanes() {
        if (this.BJSINSPECTOR) {
          return this.BJSINSPECTOR.Inspector._OpenedPane;
        }
        return 0;
      }
      /**
       * Update the scene in the inspector
       */
      setAsActiveScene() {
        if (this.BJSINSPECTOR) {
          this.BJSINSPECTOR.Inspector._SetNewScene(this._scene);
        }
      }
      popupSceneExplorer() {
        if (this.BJSINSPECTOR) {
          this.BJSINSPECTOR.Inspector.PopupSceneExplorer();
        }
      }
      popupInspector() {
        if (this.BJSINSPECTOR) {
          this.BJSINSPECTOR.Inspector.PopupInspector();
        }
      }
      popupEmbed() {
        if (this.BJSINSPECTOR) {
          this.BJSINSPECTOR.Inspector.PopupEmbed();
        }
      }
      /**
       * Launch the debugLayer.
       * @param config Define the configuration of the inspector
       * @returns a promise fulfilled when the debug layer is visible
       */
      show(config) {
        return new Promise((resolve) => {
          if (typeof this.BJSINSPECTOR == "undefined") {
            const inspectorUrl = config && config.inspectorURL ? config.inspectorURL : _DebugLayer.InspectorURL;
            Tools.LoadBabylonScript(inspectorUrl, () => {
              this._createInspector(config);
              resolve(this);
            });
          } else {
            this._createInspector(config);
            resolve(this);
          }
        });
      }
    };
    DebugLayer.InspectorURL = `${Tools._DefaultCdnUrl}/v${AbstractEngine.Version}/inspector/babylon.inspector.bundle.js`;
    DebugLayer.Config = {
      overlay: false,
      showExplorer: true,
      showInspector: true,
      embedMode: false,
      handleResize: true,
      enablePopup: true
    };
  }
});

export {
  DebugLayerTab,
  DebugLayer,
  init_debugLayer
};
//# sourceMappingURL=chunk-AI2GVAUH.js.map
