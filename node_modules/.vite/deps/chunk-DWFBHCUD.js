import {
  FlowGraphAsyncExecutionBlock,
  init_flowGraphAsyncExecutionBlock
} from "./chunk-KCEKV4UQ.js";
import {
  RichTypeAny,
  RichTypeNumber,
  init_flowGraphRichTypes
} from "./chunk-F2QE2EIU.js";
import {
  RegisterClass,
  init_typeStore
} from "./chunk-FYD2IJRD.js";
import {
  Logger,
  init_logger
} from "./chunk-RB67CL7C.js";
import {
  __esm
} from "./chunk-DZZM6G22.js";

// node_modules/@babylonjs/core/FlowGraph/Blocks/Execution/Animation/flowGraphStopAnimationBlock.js
var FlowGraphStopAnimationBlock;
var init_flowGraphStopAnimationBlock = __esm({
  "node_modules/@babylonjs/core/FlowGraph/Blocks/Execution/Animation/flowGraphStopAnimationBlock.js"() {
    init_flowGraphRichTypes();
    init_typeStore();
    init_logger();
    init_flowGraphAsyncExecutionBlock();
    FlowGraphStopAnimationBlock = class extends FlowGraphAsyncExecutionBlock {
      constructor(config) {
        super(config);
        this.animationGroup = this.registerDataInput("animationGroup", RichTypeAny);
        this.stopAtFrame = this.registerDataInput("stopAtFrame", RichTypeNumber, -1);
      }
      _preparePendingTasks(context) {
        const animationToStopValue = this.animationGroup.getValue(context);
        const stopAtFrame = this.stopAtFrame.getValue(context) ?? -1;
        const pendingStopAnimations = context._getGlobalContextVariable("pendingStopAnimations", []);
        pendingStopAnimations.push({ uniqueId: animationToStopValue.uniqueId, stopAtFrame });
        context._setGlobalContextVariable("pendingStopAnimations", pendingStopAnimations);
      }
      _cancelPendingTasks(context) {
        const animationToStopValue = this.animationGroup.getValue(context);
        const pendingStopAnimations = context._getGlobalContextVariable("pendingStopAnimations", []);
        for (let i = 0; i < pendingStopAnimations.length; i++) {
          if (pendingStopAnimations[i].uniqueId === animationToStopValue.uniqueId) {
            pendingStopAnimations.splice(i, 1);
            context._setGlobalContextVariable("pendingStopAnimations", pendingStopAnimations);
            break;
          }
        }
      }
      _execute(context) {
        const animationToStopValue = this.animationGroup.getValue(context);
        const stopTime = this.stopAtFrame.getValue(context) ?? -1;
        if (!animationToStopValue) {
          Logger.Warn("No animation group provided to stop.");
          this.error.payload = { message: "No animation group provided to stop." };
          this.error._activateSignal(context);
        }
        if (isNaN(stopTime)) {
          Logger.Warn("Invalid stop time provided.");
          this.error.payload = { message: "Invalid stop time provided." };
          this.error._activateSignal(context);
        }
        if (stopTime > 0) {
          this._startPendingTasks(context);
        } else {
          this._stopAnimation(animationToStopValue, context);
        }
        this.out._activateSignal(context);
      }
      _executeOnTick(context) {
        const animationToStopValue = this.animationGroup.getValue(context);
        const pendingStopAnimations = context._getGlobalContextVariable("pendingStopAnimations", []);
        for (let i = 0; i < pendingStopAnimations.length; i++) {
          if (pendingStopAnimations[i].uniqueId === animationToStopValue.uniqueId) {
            if (animationToStopValue.getCurrentFrame() >= pendingStopAnimations[i].stopAtFrame) {
              this._stopAnimation(animationToStopValue, context);
              pendingStopAnimations.splice(i, 1);
              context._setGlobalContextVariable("pendingStopAnimations", pendingStopAnimations);
              this.done._activateSignal(context);
              context._removePendingBlock(this);
              break;
            }
          }
        }
      }
      /**
       * @returns class name of the block.
       */
      getClassName() {
        return "FlowGraphStopAnimationBlock";
      }
      _stopAnimation(animationGroup, context) {
        const currentlyRunning = context._getGlobalContextVariable("currentlyRunningAnimationGroups", []);
        const index = currentlyRunning.indexOf(animationGroup.uniqueId);
        if (index !== -1) {
          animationGroup.stop();
          currentlyRunning.splice(index, 1);
          context._setGlobalContextVariable("currentlyRunningAnimationGroups", currentlyRunning);
        } else {
        }
      }
    };
    RegisterClass("FlowGraphStopAnimationBlock", FlowGraphStopAnimationBlock);
  }
});

export {
  FlowGraphStopAnimationBlock,
  init_flowGraphStopAnimationBlock
};
//# sourceMappingURL=chunk-DWFBHCUD.js.map
