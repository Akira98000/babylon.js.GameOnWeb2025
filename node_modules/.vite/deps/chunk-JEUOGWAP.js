import {
  Observable,
  init_observable
} from "./chunk-H6EIW4LR.js";
import {
  __esm
} from "./chunk-DZZM6G22.js";

// node_modules/@babylonjs/core/AudioV2/abstractAudio/abstractAudioNode.js
var AudioNodeType, AbstractAudioNode, AbstractNamedAudioNode;
var init_abstractAudioNode = __esm({
  "node_modules/@babylonjs/core/AudioV2/abstractAudio/abstractAudioNode.js"() {
    init_observable();
    (function(AudioNodeType2) {
      AudioNodeType2[AudioNodeType2["HAS_INPUTS"] = 1] = "HAS_INPUTS";
      AudioNodeType2[AudioNodeType2["HAS_OUTPUTS"] = 2] = "HAS_OUTPUTS";
      AudioNodeType2[AudioNodeType2["HAS_INPUTS_AND_OUTPUTS"] = 3] = "HAS_INPUTS_AND_OUTPUTS";
    })(AudioNodeType || (AudioNodeType = {}));
    AbstractAudioNode = class {
      constructor(engine, nodeType) {
        this.onDisposeObservable = new Observable();
        this.engine = engine;
        if (nodeType & 1) {
          this._upstreamNodes = /* @__PURE__ */ new Set();
        }
        if (nodeType & 2) {
          this._downstreamNodes = /* @__PURE__ */ new Set();
        }
      }
      /**
       * Releases associated resources.
       * - Triggers `onDisposeObservable`.
       * @see {@link onDisposeObservable}
       */
      dispose() {
        if (this._downstreamNodes) {
          for (const node of Array.from(this._downstreamNodes)) {
            if (!this._disconnect(node)) {
              throw new Error("Disconnect failed");
            }
          }
          this._downstreamNodes.clear();
        }
        if (this._upstreamNodes) {
          for (const node of Array.from(this._upstreamNodes)) {
            if (!node._disconnect(this)) {
              throw new Error("Disconnect failed");
            }
          }
          this._upstreamNodes.clear();
        }
        this.onDisposeObservable.notifyObservers(this);
        this.onDisposeObservable.clear();
      }
      /**
       * Connect to a downstream audio input node.
       * @param node - The downstream audio input node to connect
       * @returns `true` if the node is successfully connected; otherwise `false`
       */
      _connect(node) {
        if (!this._downstreamNodes) {
          return false;
        }
        if (this._downstreamNodes.has(node)) {
          return false;
        }
        if (!node._onConnect(this)) {
          return false;
        }
        this._downstreamNodes.add(node);
        return true;
      }
      /**
       * Disconnects a downstream audio input node.
       * @param node - The downstream audio input node to disconnect
       * @returns `true` if the node is successfully disconnected; otherwise `false`
       */
      _disconnect(node) {
        if (!this._downstreamNodes) {
          return false;
        }
        if (!this._downstreamNodes.delete(node)) {
          return false;
        }
        return node._onDisconnect(this);
      }
      /**
       * Called when an upstream audio output node is connecting.
       * @param node - The connecting upstream audio node
       * @returns `true` if the node is successfully connected; otherwise `false`
       */
      _onConnect(node) {
        if (!this._upstreamNodes) {
          return false;
        }
        if (this._upstreamNodes.has(node)) {
          return false;
        }
        this._upstreamNodes.add(node);
        return true;
      }
      /**
       * Called when an upstream audio output node disconnects.
       * @param node - The disconnecting upstream audio node
       * @returns `true` if node is sucessfully disconnected; otherwise `false`
       */
      _onDisconnect(node) {
        var _a;
        return ((_a = this._upstreamNodes) == null ? void 0 : _a.delete(node)) ?? false;
      }
    };
    AbstractNamedAudioNode = class extends AbstractAudioNode {
      constructor(name, engine, nodeType) {
        super(engine, nodeType);
        this.onNameChangedObservable = new Observable();
        this._name = name;
      }
      /**
       * The name of the audio node.
       * - Triggers `onNameChangedObservable` when changed.
       * @see {@link onNameChangedObservable}
       */
      get name() {
        return this._name;
      }
      set name(newName) {
        if (this._name === newName) {
          return;
        }
        const oldName = this._name;
        this._name = newName;
        this.onNameChangedObservable.notifyObservers({ newName, oldName, node: this });
      }
      dispose() {
        super.dispose();
        this.onNameChangedObservable.clear();
      }
    };
  }
});

// node_modules/@babylonjs/core/AudioV2/abstractAudio/subNodes/abstractAudioSubGraph.js
var _AbstractAudioSubGraph;
var init_abstractAudioSubGraph = __esm({
  "node_modules/@babylonjs/core/AudioV2/abstractAudio/subNodes/abstractAudioSubGraph.js"() {
    _AbstractAudioSubGraph = class {
      constructor() {
        this._createSubNodePromises = {};
        this._subNodes = {};
        this._onSubNodeDisposed = (node) => {
          const subNode = node;
          delete this._subNodes[subNode.name];
          this._onSubNodesChanged();
        };
      }
      /**
       * Executes the given callback with the named sub node, creating the sub node if needed.
       *
       * Note that `callback` is executed synchronously if the sub node already exists, otherwise the sub node is created
       * asynchronously before `callback` is executed.
       *
       * @param name The name of the sub node
       * @param callback The function to call with the named sub node
       */
      callOnSubNode(name, callback) {
        const node = this.getSubNode(name);
        if (node) {
          callback(node);
          return;
        }
        const promise = this._createSubNodePromises[name] ?? this._createAndAddSubNode(name);
        promise.then((node2) => {
          callback(node2);
        });
      }
      /**
       * Releases associated resources.
       */
      dispose() {
        const subNodes = Object.values(this._subNodes);
        for (const subNode of subNodes) {
          subNode.dispose();
        }
        this._subNodes = {};
        this._createSubNodePromises = {};
      }
      /**
       * Gets a previously created sub node.
       * @param name - The name of the sub node
       * @returns The named sub node, or `null` if it has not been created, yet
       * @internal
       * */
      getSubNode(name) {
        return this._subNodes[name] ?? null;
      }
      /**
       * Called when sub-nodes are added or removed.
       * - Override this to connect and reconnect sub-nodes as needed.
       */
      _onSubNodesChanged() {
      }
      _createSubNodePromisesResolved() {
        return Promise.all(Object.values(this._createSubNodePromises));
      }
      _addSubNode(node) {
        this._subNodes[node.name] = node;
        node.onDisposeObservable.addOnce(this._onSubNodeDisposed);
        this._onSubNodesChanged();
      }
      _createAndAddSubNode(name) {
        const promise = this._createSubNode(name);
        if (!promise) {
          return Promise.reject(`Failed to create subnode "${name}"`);
        }
        this._createSubNodePromises[name] = new Promise((resolve, reject) => {
          promise.then((node) => {
            this._addSubNode(node);
            resolve(node);
          }).catch((error) => {
            reject(error);
          });
        });
        return promise;
      }
    };
  }
});

// node_modules/@babylonjs/core/AudioV2/abstractAudio/subNodes/abstractAudioSubNode.js
var _AbstractAudioSubNode;
var init_abstractAudioSubNode = __esm({
  "node_modules/@babylonjs/core/AudioV2/abstractAudio/subNodes/abstractAudioSubNode.js"() {
    init_abstractAudioNode();
    _AbstractAudioSubNode = class extends AbstractNamedAudioNode {
      /** @internal */
      constructor(name, engine) {
        super(
          name,
          engine,
          3
          /* AudioNodeType.HAS_INPUTS_AND_OUTPUTS */
        );
      }
      /** @internal */
      connect(node) {
        if (!this._connect(node)) {
          throw new Error("Connect failed");
        }
      }
      /** @internal */
      disconnect(node) {
        if (!this._disconnect(node)) {
          throw new Error("Disconnect failed");
        }
      }
      /** @internal */
      disconnectAll() {
        if (!this._downstreamNodes) {
          throw new Error("Disconnect failed");
        }
        const it = this._downstreamNodes.values();
        for (let next = it.next(); !next.done; next = it.next()) {
          if (!this._disconnect(next.value)) {
            throw new Error("Disconnect failed");
          }
        }
      }
    };
  }
});

// node_modules/@babylonjs/core/AudioV2/abstractAudio/subNodes/volumeAudioSubNode.js
function _GetVolumeAudioSubNode(subGraph) {
  return subGraph.getSubNode(
    "Volume"
    /* AudioSubNode.VOLUME */
  );
}
function _GetVolumeAudioProperty(subGraph, property) {
  var _a;
  return ((_a = _GetVolumeAudioSubNode(subGraph)) == null ? void 0 : _a[property]) ?? _VolumeAudioDefaults[property];
}
var _VolumeAudioDefaults, _VolumeAudioSubNode;
var init_volumeAudioSubNode = __esm({
  "node_modules/@babylonjs/core/AudioV2/abstractAudio/subNodes/volumeAudioSubNode.js"() {
    init_abstractAudioSubNode();
    _VolumeAudioDefaults = {
      volume: 1
    };
    _VolumeAudioSubNode = class extends _AbstractAudioSubNode {
      constructor(engine) {
        super("Volume", engine);
      }
      /** @internal */
      setOptions(options) {
        this.volume = options.volume ?? _VolumeAudioDefaults.volume;
      }
    };
  }
});

// node_modules/@babylonjs/core/AudioV2/webAudio/subNodes/volumeWebAudioSubNode.js
async function _CreateVolumeAudioSubNodeAsync(engine) {
  return new _VolumeWebAudioSubNode(engine);
}
var _VolumeWebAudioSubNode;
var init_volumeWebAudioSubNode = __esm({
  "node_modules/@babylonjs/core/AudioV2/webAudio/subNodes/volumeWebAudioSubNode.js"() {
    init_volumeAudioSubNode();
    _VolumeWebAudioSubNode = class extends _VolumeAudioSubNode {
      /** @internal */
      constructor(engine) {
        super(engine);
        this.node = new GainNode(engine.audioContext);
      }
      /** @internal */
      get volume() {
        return this.node.gain.value;
      }
      /** @internal */
      set volume(value) {
        this.node.gain.value = value;
      }
      /** @internal */
      get inNode() {
        return this.node;
      }
      /** @internal */
      get outNode() {
        return this.node;
      }
      _connect(node) {
        const connected = super._connect(node);
        if (!connected) {
          return false;
        }
        if (node.inNode) {
          this.node.connect(node.inNode);
        }
        return true;
      }
      _disconnect(node) {
        const disconnected = super._disconnect(node);
        if (!disconnected) {
          return false;
        }
        if (node.inNode) {
          this.node.disconnect(node.inNode);
        }
        return true;
      }
      /** @internal */
      getClassName() {
        return "_VolumeWebAudioSubNode";
      }
    };
  }
});

// node_modules/@babylonjs/core/AudioV2/webAudio/subNodes/webAudioBaseSubGraph.js
var _WebAudioBaseSubGraph;
var init_webAudioBaseSubGraph = __esm({
  "node_modules/@babylonjs/core/AudioV2/webAudio/subNodes/webAudioBaseSubGraph.js"() {
    init_abstractAudioSubGraph();
    init_volumeAudioSubNode();
    init_volumeWebAudioSubNode();
    _WebAudioBaseSubGraph = class extends _AbstractAudioSubGraph {
      /** @internal */
      constructor(owner) {
        super();
        this._outNode = null;
        this._owner = owner;
      }
      /** @internal */
      async init(options) {
        this._createAndAddSubNode(
          "Volume"
          /* AudioSubNode.VOLUME */
        );
        await this._createSubNodePromisesResolved();
        const volumeNode = _GetVolumeAudioSubNode(this);
        if (!volumeNode) {
          throw new Error("No volume subnode.");
        }
        volumeNode.setOptions(options);
        if (volumeNode.getClassName() !== "_VolumeWebAudioSubNode") {
          throw new Error("Not a WebAudio subnode.");
        }
        this._outNode = volumeNode.node;
        if (this._outNode && this._downstreamNodes) {
          const it = this._downstreamNodes.values();
          for (let next = it.next(); !next.done; next = it.next()) {
            const inNode = next.value.inNode;
            if (inNode) {
              this._outNode.connect(inNode);
            }
          }
        }
      }
      /** @internal */
      get inNode() {
        return this._outNode;
      }
      /** @internal */
      get outNode() {
        return this._outNode;
      }
      _createSubNode(name) {
        switch (name) {
          case "Volume":
            return _CreateVolumeAudioSubNodeAsync(this._owner.engine);
          default:
            return null;
        }
      }
    };
  }
});

export {
  AudioNodeType,
  AbstractAudioNode,
  AbstractNamedAudioNode,
  init_abstractAudioNode,
  _AbstractAudioSubNode,
  init_abstractAudioSubNode,
  _GetVolumeAudioSubNode,
  _GetVolumeAudioProperty,
  init_volumeAudioSubNode,
  _WebAudioBaseSubGraph,
  init_webAudioBaseSubGraph
};
//# sourceMappingURL=chunk-JEUOGWAP.js.map
